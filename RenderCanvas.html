<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Car Driving</title>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <style>
            html,body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #canvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id ="canvas"></canvas>
        <script>
            window.addEventListener("DOMContentLoaded", function(){
                var canvas = document.getElementById("canvas");
                var engine = new BABYLON.Engine(canvas, true);

                // flex that engine
                engine.displayLoadingUI();

                var createScene = function() {
                    var scene = new BABYLON.Scene(engine);

                    // enable debug mode
                    // scene.debugLayer.show()

                    // enable physics
                    scene.enablePhysics(new BABYLON.Vector3(0,-32, 0), new BABYLON.OimoJSPlugin());
                       
                    // camera
                    var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 20, new BABYLON.Vector3(0, 0, 0), scene);
                    camera.setPosition(new BABYLON.Vector3(25, 10, 0));	  
                    camera.attachControl(canvas, true)
                    camera.inputs.attached.pointers.buttons = [0] // disable right mouse button drag
                    camera.lowerRadiusLimit = 20
                    camera.upperRadiusLimit = 40
                    var cameraStartAlpha = camera.alpha
                    var cameraStartBeta = camera.beta
                    var cameraStartRadius = camera.radius
                    camera.checkCollisions = true;

                    // fps camera
                    var camera2 = new BABYLON.UniversalCamera("camera2", new BABYLON.Vector3(0, 0, 0), scene);
                    camera2.position = new BABYLON.Vector3(0.2, 4.5, 1);
                    camera2.rotation = new BABYLON.Vector3(0, 4.68, 0);
                    
                    // lights
                    var light1 = new BABYLON.DirectionalLight("light1", new BABYLON.Vector3(1, 2, 0), scene);
                    var light2 = new BABYLON.HemisphericLight("light2", new BABYLON.Vector3(0, 1, 0), scene);
                    light2.intensity = 0.75;

                    // glow layer
                    var gl = new BABYLON.GlowLayer("glow", scene, { 
                        mainTextureFixedSize: 1024,
                        blurKernelSize: 64
                    });
                    
                    /***************************Car*********************************************/
                    
                    var createCar = () => {
                        //Car Body Material 
                        var bodyMaterial = new BABYLON.StandardMaterial("body_mat", scene);
                        bodyMaterial.diffuseColor = new BABYLON.Color3(1.0, 0.25, 0.25);
                        bodyMaterial.backFaceCulling = false;
                        bodyMaterial.alpha = 0

                        //Array of points for trapezium side of car.
                        var side = [new BABYLON.Vector3(-6.5, 1.5, -2),
                                    new BABYLON.Vector3(2.5, 1.5, -2),
                                    new BABYLON.Vector3(3.5, 0.5, -2),
                                    new BABYLON.Vector3(-9.5, 0.5, -2)				
                        ];
                        
                        side.push(side[0]);	//close trapezium
                        
                        //Array of points for the extrusion path
                        var extrudePath = [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 4)];
                        
                        //Create body and apply material
                        var carBody = BABYLON.MeshBuilder.ExtrudeShape("body", {shape: side, path: extrudePath, cap : BABYLON.Mesh.CAP_ALL}, scene);
                        carBody.material = bodyMaterial;
                        carBody.physicsImpostor = new BABYLON.PhysicsImpostor(carBody, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 1, friction: 0.4, restitution: 0.8}, scene);

                        return carBody
                    }
                    
                    var car = createCar()
                    camera.parent = car;
                    camera2.parent = car
                    var carStartRotation = car.rotationQuaternion.clone();
                    
                    var carWheels = []
                    var carLights = [[], []]
                    var carLightStartMaterial;
                    var carSterringWheel;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Volkswagen Touareg 2/model/", "Touareg.obj", scene, (meshes) => {
                        meshes.forEach((mesh, index) => {
                            mesh.parent = car
                            mesh.position = new BABYLON.Vector3(-2, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(0.0035, 0.0035, 0.0035);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)

                            var wheelIndex = [562,570,573,542,553,594,579,584,592,603,608,610,596,600,598,606,604,602,564,568,566,572,576,574,586,590,580,578,582,588,550,558,548,560,554,546,556,544,552]
                            wheelIndex.forEach(i => {
                                if (i == index) {
                                    mesh.dispose()
                                }
                            })

                            var leftLightIndex = [474, 506, 231]
                            leftLightIndex.forEach(i => {
                                if (i == index) {
                                    var mat = new BABYLON.StandardMaterial('mat', scene);
                                    mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/GLBK11.jpg");
                                    mat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                                    mat.backFaceCulling = false
                                    mesh.material = mat;
                                    carLightStartMaterial = mat
                                    carLights[0].push(mesh)
                                }
                            })

                            var rightLightIndex = [462, 496, 215]
                            rightLightIndex.forEach(i => {
                                if (i == index) {
                                    var mat = new BABYLON.StandardMaterial('mat', scene);
                                    mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/GLBK11.jpg");
                                    mat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                                    mat.backFaceCulling = false
                                    mesh.material = mat;
                                    carLights[1].push(mesh)
                                }
                            })

                            if (index == 13 || index == 32 || index == 239) {
                                var pbr = new BABYLON.PBRMaterial("pbr", scene);
                                mesh.material = pbr;

                                pbr.metallic = 0.0;
                                pbr.roughness = 0;   
                                pbr.albedoTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/AS2_carpaint_metallic.jpg");
                                pbr.backFaceCulling = false
                            }

                            if (index == 446 || index == 24) {
                                var glass = new BABYLON.PBRMaterial("glass", scene);
                                glass.alpha = 0.5;
                                glass.reflectivityColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                                glass.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.95);
                                glass.backFaceCulling = false
                                mesh.material = glass;
                            }

                            var rightLightIndex = [434, 536, 538, 540]
                            rightLightIndex.forEach(i => {
                                if (i == index) {
                                    var mat = new BABYLON.StandardMaterial('mat', scene);
                                    mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/AS2_leather_06.jpg");
                                    mat.diffuseColor = new BABYLON.Color3(1, 0.8, 0);
                                    mesh.material = mat;
                                }
                            })

                            if (index == 109) {
                                var mat = new BABYLON.StandardMaterial('mat', scene);
                                mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/Metals.Ornamental Metals.Plate.Mesh.cutout.jpg");
                                mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                                mesh.material = mat;
                            }

                            if (index == 420) {
                                carSterringWheel = mesh
                            }

                            if (index == 438) {
                                var mat = new BABYLON.StandardMaterial('mat', scene);
                                mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/SpeedWin.jpg");
                                mat.diffuseTexture.wAng = Math.PI/2; 
                                mesh.material = mat;
                            }

                            if (index == 440) {
                                var mat = new BABYLON.StandardMaterial('mat', scene);
                                mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/computer.jpg");
                                mat.diffuseTexture.wAng = -Math.PI/2; 
                                mat.diffuseTexture.vAng = Math.PI; 
                                mesh.material = mat;
                            }

                            if (index == 49 || index == 293) {
                                var mat = new BABYLON.StandardMaterial('mat', scene);
                                mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/218411094_tp.jpg");
                                mesh.material = mat;
                            }
                            

                            if (index == 350) {
                                //Ensure working with new values for glass by computing and obtaining its worldMatrix
                                mesh.computeWorldMatrix(true);
                                var glass_worldMatrix = mesh.getWorldMatrix();
                            
                                //Obtain normals for plane and assign one of them as the normal
                                var glass_vertexData = mesh.getVerticesData("normal");
                                var glassNormal = new BABYLON.Vector3(glass_vertexData[0], glass_vertexData[1], glass_vertexData[2]);	
                                //Use worldMatrix to transform normal into its current value
                                glassNormal = new BABYLON.Vector3.TransformNormal(glassNormal, glass_worldMatrix)
                            
                                //Create reflecting surface for mirror surface
                                var reflector = new BABYLON.Plane.FromPositionAndNormal(mesh.position, glassNormal.scale(-1));
                                
                                //Create the mirror material
                                var mirrorMaterial = new BABYLON.StandardMaterial("mirror", scene);
                                mirrorMaterial.reflectionTexture = new BABYLON.MirrorTexture("mirror", 1024, scene, true);
                                mirrorMaterial.reflectionTexture.mirrorPlane = reflector;
                                mirrorMaterial.reflectionTexture.renderList = meshes;
                                mirrorMaterial.reflectionTexture.level = 1;
                            
                                // mesh.material = mirrorMaterial;
                            }

                            // mesh identifier

                            // mesh.showBoundingBox = true;
                            // mesh.actionManager = new BABYLON.ActionManager(scene);
                            // mesh.actionManager.registerAction(
                            //     new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                            //         function(event) {
                            //             console.log(index);
                            //             mesh.dispose()
                            //         }
                            //     )
                            // )
                            
                        });

                        new BABYLON.SceneLoader.ImportMesh(null, "./assets/Volkswagen Touareg 2/model/", "Tire.obj", scene, (meshes) => {
                            var carWheel = BABYLON.Mesh.MergeMeshes(meshes, true, true, undefined, false, true)
                            carWheel.parent = car
                            carWheel.position = new BABYLON.Vector3(-7, 1.2, 2.8)
                            carWheel.scaling = new BABYLON.Vector3(0.0035, 0.0035, 0.0035);
                            carWheel.rotation = new BABYLON.Vector3(0, 0, 0)
                            carWheels.push(carWheel)
                            
                            var carWheel2 = carWheel.createInstance()
                            carWheel2.parent = car
                            carWheel2.position = new BABYLON.Vector3(-7, 1.2, -2.94)
                            carWheel2.rotation = new BABYLON.Vector3(0, Math.PI, 0)
                            carWheels.push(carWheel2)

                            var carWheel3 = carWheel.createInstance()
                            carWheel3.parent = car
                            carWheel3.position = new BABYLON.Vector3(3, 1.2, 2.8)
                            carWheels.push(carWheel3)

                            var carWheel4 = carWheel.createInstance()
                            carWheel4.parent = car
                            carWheel4.position = new BABYLON.Vector3(3, 1.2, -2.94)
                            carWheel4.rotation = new BABYLON.Vector3(0, Math.PI, 0)
                            carWheels.push(carWheel4)
                        })
                    });
                    
                    /***************************End Car*********************************************/
                    
                    /*****************************Map********************************************/

                    var mapMeshes;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Objects Real.obj", scene, (meshes) => {
                        mapMeshes = meshes
                        meshes.forEach((mesh, index) => {
                            mesh.position = new BABYLON.Vector3(0, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                            // mesh.showBoundingBox = true;
                            mesh.checkCollisions = true
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);

                            // check for collisions
                            car.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function(main, collided) {
                                if (!fail) {
                                    // console.log(collided.object.name)
                                    lose()
                                }
                            });
                        });
                    });

                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Road.obj", scene, (meshes) => {
                        meshes.forEach((mesh, index) => {
                            mesh.position = new BABYLON.Vector3(0, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                            // mesh.showBoundingBox = true;
                            mesh.checkCollisions = true
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0 , friction: 0.8}, scene);
                        });
                    });

                    // new BABYLON.SceneLoader.ImportMesh(null, "./assets/traffic light/", "traffic light.obj", scene, (meshes) => {
                    //     meshes.forEach((mesh, index) => {
                    //         mesh.position = new BABYLON.Vector3(-120, 0, -12)
                    //         mesh.scaling = new BABYLON.Vector3(0.4, 0.4, 0.4);
                    //         mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                    //         // mesh.showBoundingBox = true;
                    //         mesh.checkCollisions = true
                    //         mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);
                    //     });
                    // });

                    // var box1 = BABYLON.Mesh.CreateBox("box1", 5, scene);
                    // box1.scaling = new BABYLON.Vector3(3, 3, 3);
                    // box1.rotation.x = Math.PI/3;
                    // box1.rotation.y = -190;
                    // box1.position.x -= 100;
                    // box1.position.y -= 3;
                    // box1.physicsImpostor = new BABYLON.PhysicsImpostor(box1,BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.01, restitution: 0 }, scene);

                    /*****************************End Map********************************************/ 
                    
                    /*****************************Skybox********************************************/ 

                    var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:500}, scene)
                    var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene)
                    skyboxMaterial.backFaceCulling = false
                    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("./assets/skybox/skybox", scene)
                    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE

                    skybox.infiniteDistance = true
                    skyboxMaterial.disableLighting = true
                    skybox.material = skyboxMaterial

                    scene.fogMode = BABYLON.Scene.FOGMODE_EXP
                    scene.fogDensity = 0.002
                    scene.fogColor = new BABYLON.Color3(0.7, 0.7, 1)

                    /*****************************End Skybox********************************************/

                    /*****************************GUI********************************************/ 

                    var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

                    var image = new BABYLON.GUI.Image("", "./assets/black.png");
                    image.alpha = 0.5
                    image.isVisible = false
                    gui.addControl(image);    

                    var text1 = new BABYLON.GUI.TextBlock();
                    text1.text = "You died";
                    text1.color = "white";
                    text1.fontSize = 80;
                    text1.top = "-100px"
                    text1.isVisible = false
                    gui.addControl(text1); 

                    var button = BABYLON.GUI.Button.CreateSimpleButton("", "Retry");
                    button.width = 0.2;
                    button.height = "40px";
                    button.color = "white";
                    button.background = "red";
                    button.isVisible = false
                    button.onPointerClickObservable.add(function () {
                        image.isVisible = false
                        text1.isVisible = false
                        button.isVisible = false
                        window.clearTimeout(stopCarPhysicsTimeout)
                        restart()
                    });
                    gui.addControl(button); 

                    /*****************************End GUI********************************************/
                    
                    /*****************************Physics********************************************/

                    function transformForce(mesh, vec) {
                        var mymatrix = new BABYLON.Matrix();
                        mesh.rotationQuaternion.toRotationMatrix(mymatrix);
                        return BABYLON.Vector3.TransformNormal(vec, mymatrix);
                    };

                    var rotate = function(mesh, direction, power) {
                        // console.log("angular y: " + mesh.physicsImpostor.getAngularVelocity().y);
                        var maxRotation = 1;

                        // limit left rotation
                        if (mesh.physicsImpostor.getAngularVelocity().y < -maxRotation) 
                            mesh.physicsImpostor.setAngularVelocity( 
                                new BABYLON.Vector3(mesh.physicsImpostor.getAngularVelocity().x, -maxRotation, mesh.physicsImpostor.getAngularVelocity().z)
                            );

                        // limit right rotation
                        if (mesh.physicsImpostor.getAngularVelocity().y > maxRotation) 
                            mesh.physicsImpostor.setAngularVelocity( 
                                new BABYLON.Vector3(mesh.physicsImpostor.getAngularVelocity().x, maxRotation, mesh.physicsImpostor.getAngularVelocity().z)
                            );
                                
                        mesh.physicsImpostor.setAngularVelocity(
                            mesh.physicsImpostor.getAngularVelocity().add(
                                direction.scale(power)
                            )
                        );
                    }

                    var translate = function(mesh, direction, power) {
                        // console.log("linear x: " + mesh.physicsImpostor.getLinearVelocity().x);
                        // console.log("linear z: " + mesh.physicsImpostor.getLinearVelocity().z);
                        var maxSpeed = 20;

                        // limit forward velocity speed
                        if (mesh.physicsImpostor.getLinearVelocity().x < -maxSpeed) 
                            mesh.physicsImpostor.setLinearVelocity(
                                new BABYLON.Vector3( -maxSpeed, mesh.physicsImpostor.getLinearVelocity().y, mesh.physicsImpostor.getLinearVelocity().z)
                            );

                        // limit backward velocity speed
                        if (mesh.physicsImpostor.getLinearVelocity().x > maxSpeed) 
                            mesh.physicsImpostor.setLinearVelocity(
                                new BABYLON.Vector3( maxSpeed, mesh.physicsImpostor.getLinearVelocity().y, mesh.physicsImpostor.getLinearVelocity().z)
                            );

                        // limit z velocity to prevent slippery floor
                        // if (mesh.physicsImpostor.getLinearVelocity().z < -1) 
                        //     mesh.physicsImpostor.setLinearVelocity(
                        //         new BABYLON.Vector3( mesh.physicsImpostor.getLinearVelocity().x, mesh.physicsImpostor.getLinearVelocity().y, -1)
                        //     );

                        // if (mesh.physicsImpostor.getLinearVelocity().z > 1) 
                        //     mesh.physicsImpostor.setLinearVelocity(
                        //         new BABYLON.Vector3( mesh.physicsImpostor.getLinearVelocity().x, mesh.physicsImpostor.getLinearVelocity().y, 1)
                        //     );

                        mesh.physicsImpostor.setLinearVelocity(
                            mesh.physicsImpostor.getLinearVelocity().add(
                                transformForce(mesh, direction.scale(power))
                            )
                        );
                    }

                    /*****************************End Physics********************************************/

                    /*****************************Animations********************************************/

                    var cutscene_mode = 0
                    var flip = false

                    var camera3 = new BABYLON.UniversalCamera("camera3",  new BABYLON.Vector3(0, 0, 0), scene);
                    
                    var frameRate = 20
                    
                    /*************First Cutscene*************/
                    
                    function cutscene1() {

                        cutscene_mode = 1
                        activeCamera = 3
                        // camera3.attachControl(scene, false)
                        scene.activeCamera = camera3  
    
                        car.physicsImpostor.dispose()
                        image.alpha = 0
                        image.isVisible = true
    
                        var camera_rotate = new BABYLON.Animation("camera_rotate", "rotation", frameRate, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                        
                        var camera_rotate_keys = []; 
    
                        // scene 1 - street panoramic view
                        camera_rotate_keys.push({
                            frame: 0,
                            value: new BABYLON.Vector3(-9.8, -10, 0)
                        });
    
                        camera_rotate_keys.push({
                            frame: 8 * frameRate,
                            value: new BABYLON.Vector3(-9.8, -10, 0)
                        });
    
                        // scene 2 - headlight showcase
                        camera_rotate_keys.push({
                            frame: 8 * frameRate,
                            value: new BABYLON.Vector3(0.25, 7.8, 0)
                        });
    
                        camera_rotate_keys.push({
                            frame: 13 * frameRate, 
                            value: new BABYLON.Vector3(0.25, 7.8, 0)
                        });
    
                        // scene 3 - drift
                        camera_rotate_keys.push({
                            frame: 13 * frameRate, 
                            value: new BABYLON.Vector3(0.48, 8.5, 0)
                        });
    
                        camera_rotate_keys.push({
                            frame: 16 * frameRate, 
                            value: new BABYLON.Vector3(0.48, 8.5, 0)
                        });
    
                        camera_rotate_keys.push({
                            frame: 19 * frameRate, 
                            value: new BABYLON.Vector3(0.48, 11.6, 0)
                        });
    
                        camera_rotate.setKeys(camera_rotate_keys);
                        
                        var camera_position = new BABYLON.Animation("camera_position", "position", frameRate, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                        
                        var camera_position_keys = []; 
    
                        // scene 1 - street panoramic view
                        camera_position_keys.push({
                            frame: 0,
                            value: new BABYLON.Vector3(20, 20, -30)
                        });
    
                        camera_position_keys.push({
                            frame: 8 * frameRate,
                            value: new BABYLON.Vector3(-80, 20, -30)
                        });
    
                        // scene 2 - headlight showcase
                        camera_position_keys.push({
                            frame: 8 * frameRate,
                            value: new BABYLON.Vector3(-108, 4, 4)
                        });
    
                        camera_position_keys.push({
                            frame: 13 * frameRate,
                            value: new BABYLON.Vector3(-108, 4, -1)
                        });
    
                        // scene 3 - drift
                        camera_position_keys.push({
                            frame: 13 * frameRate,
                            value: new BABYLON.Vector3(-120, 16, 20)
                        });
    
                        camera_position_keys.push({
                            frame: 16 * frameRate,
                            value: new BABYLON.Vector3(-120, 12, 20)
                        });
    
                        camera_position.setKeys(camera_position_keys);
    
                        // car animation
    
                        var car_move = new BABYLON.Animation("car_move", "position", frameRate, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                        
                        var car_move_keys = []; 
    
                        car_move_keys.push({
                            frame: 0,
                            value: new BABYLON.Vector3(0, 0, 0)
                        });
    
                        car_move_keys.push({
                            frame: 8 * frameRate,
                            value: new BABYLON.Vector3(-89, -0.5, 0)
                        });
    
                        car_move_keys.push({
                            frame: 8 * frameRate + 1,
                            value: new BABYLON.Vector3(-89, -0.5, 0)
                        });
    
                        car_move.setKeys(car_move_keys);
    
                        var fadeout = new BABYLON.Animation("fadeout", "alpha", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                        
                        var fadeout_keys = []; 
    
                        fadeout_keys.push({
                            frame: 0,
                            value: 1
                        });
    
                        fadeout_keys.push({
                            frame: 1 * frameRate,
                            value: 0
                        });
    
                        fadeout_keys.push({
                            frame: 7 * frameRate,
                            value: 0
                        });
    
                        fadeout_keys.push({
                            frame: 8 * frameRate,
                            value: 1
                        });
    
                        fadeout_keys.push({
                            frame: 9 * frameRate,
                            value: 0
                        });
    
                        fadeout_keys.push({
                            frame: 12 * frameRate,
                            value: 0
                        });
    
                        fadeout_keys.push({
                            frame: 13 * frameRate,
                            value: 1
                        });
    
                        fadeout_keys.push({
                            frame: 14 * frameRate,
                            value: 0
                        });
    
                        fadeout_keys.push({
                            frame: 16 * frameRate,
                            value: 0
                        });
    
                        fadeout_keys.push({
                            frame: 17 * frameRate,
                            value: 1
                        });
    
                        fadeout.setKeys(fadeout_keys);

                        scene.beginDirectAnimation(camera3, [camera_position, camera_rotate], 0, 25 * frameRate, false);
                        scene.beginDirectAnimation(car, [car_move], 0, 25 * frameRate, false);
                        scene.beginDirectAnimation(image, [fadeout], 0, 25 * frameRate, false);
                    }

                    function cutscene1Logic() {
                        // console.log(camera3.rotation)
                        if (cutscene_mode === 1) {
                            if (camera3.position.x > -108) {
                                mf = true
                            }
                            if (camera3.position.x === -108 && !flip) {
                                mf = false
                                car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 1, friction: 0.4, restitution: 0.8}, scene);
                                car.physicsImpostor.dispose()
                                setTimeout(function () {
                                    blinkRight()
                                }, 300)
                                flip = true
                            }
                            if (camera3.position.x === -120 && flip) {
                                setTimeout(function () {
                                    blinkRight()
                                    car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 1, friction: 0.4, restitution: 0.8}, scene);
                                    rr = true
                                    setTimeout(function () {
                                        rr = false
                                    }, 100)
                                    setTimeout(function () {
                                        mf = true
                                        setTimeout(function () {
                                            cutscene_mode = 0
                                            activeCamera = 2
                                            changeCamera()
                                            image.alpha = 0.5
                                            image.isVisible = false
                                            mapMeshes.forEach((mesh, index) => {
                                                car.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function(main, collided) {
                                                    if (!fail) {
                                                        lose()
                                                    }
                                                });
                                            });
                                            restart()
                                        },3000) 
                                    }, 1000)
                                }, 800)
                                flip = false
                            }
                        }
                    }

                    // cutscene1()

                    /*************End First Cutscene*************/

                    /*************Second Cutscene*************/


                    /********************************************End Animations********************************************/

                    /*****************************Input********************************************/

                    var mf = false; // move forward
                    var mb = false; // move backward
                    var rl = false; // rotate left
                    var rr = false; // rotate right
                    var brake = false

                    var left_indicator_turned_on = false;
                    var left_indicator;
                    var right_indicator_turned_on = false;
                    var right_indicator;

                    var activeCamera = 1
                    var blinker_state = 0 // blinker state is on or off

                    function blink(num) { // called for blinking car light
                        // reset material to prevent light getting stuck when stopping
                        carLights.forEach((array, index) => {
                            array.forEach((mesh, index) => {
                                mesh.material = carLightStartMaterial
                            })
                        })
                        if (blinker_state == 0) {
                            carLights[num].forEach((mesh, index) => {
                                mesh.material = new BABYLON.StandardMaterial('', scene)
                                mesh.material.diffuseColor = BABYLON.Color3.Yellow()
                                mesh.material.emissiveColor = BABYLON.Color3.Yellow()
                            })
                            blinker_state++
                        }
                        else {
                            carLights[num].forEach((mesh, index) => {
                                mesh.material = carLightStartMaterial
                            })
                            blinker_state = 0
                        }
                    }

                    function blinkLeft() {
                        right_indicator_turned_on = false
                        clearInterval(right_indicator)
                        if (!left_indicator_turned_on)
                            left_indicator = setInterval( function() { blink(0); }, 500 );
                        else {
                            clearInterval(left_indicator)
                            carLights.forEach((array, index) => {
                                array.forEach((mesh, index) => {
                                    mesh.material = carLightStartMaterial
                                })
                            })
                        }
                        left_indicator_turned_on = !left_indicator_turned_on
                    }

                    function blinkRight() {
                        left_indicator_turned_on = false
                        clearInterval(left_indicator)
                        if (!right_indicator_turned_on)
                            right_indicator = setInterval( function() { blink(1); }, 500 );
                        else {
                            clearInterval(right_indicator)
                            carLights.forEach((array, index) => {
                                array.forEach((mesh, index) => {
                                    mesh.material = carLightStartMaterial
                                })
                            })
                        }
                        right_indicator_turned_on = !right_indicator_turned_on
                    }

                    function changeCamera() {
                        if(activeCamera === 1) {
                            activeCamera = 2;
                            camera.detachControl(canvas);
                        }
                        else if(activeCamera === 2) {
                            activeCamera = 1;
                            camera2.detachControl(canvas);
                        }
                        scene.activeCamera = activeCamera === 1 ? camera : camera2;
                        activeCamera === 1 && camera.attachControl(canvas, false)
                    }
                    
                    window.addEventListener('keydown',function (e) {
                        if (!fail) {
                            switch (e.keyCode) {
                                case 87://w
                                    mf = true;
                                    break;
                                case 83://s
                                    mb = true;
                                    break;
                                case 65://a
                                    rl = true;
                                    break;
                                case 68://d
                                    rr = true;
                                    break;
                                case 32://space
                                    brake = true
                                    break;
                                case 82://r
                                    restart()
                                    break;
                                case 81://q
                                    blinkLeft()
                                    break;
                                case 69://e
                                    blinkRight()
                                    break;
                                case 86://v
                                    changeCamera()
                                    break;
                            }
                        }
                    });

                    window.addEventListener('keyup',function (e) {
                        if (!fail) {
                            switch (e.keyCode) {
                                case 87://w
                                    mf = false;
                                    break;
                                case 83://s
                                    mb = false;
                                    break;
                                case 65://a
                                    rl = false;
                                    break;
                                case 68://d
                                    rr = false;
                                    break;
                                case 32://space
                                    brake = false
                                    break;
                                case 82://r
                                    break;
                                case 81://q
                                    break;
                                case 69://e
                                    break;
                                case 86://v
                                    break;
                            }
                        }
                    });

                    /*****************************End Input********************************************/

                    var fail = false
                    var stopCarPhysicsTimeout;

                    function stopCarPhysics() {
                        mf = false;
                        mb = false;
                        rl = false;
                        rr = false;
                        car.physicsImpostor.setLinearVelocity(
                            new BABYLON.Vector3(0, 0, 0)
                        );
                        car.physicsImpostor.setAngularVelocity(
                            new BABYLON.Vector3(0, 0, 0)
                        );
                    }

                    function restart() {
                        stopCarPhysics()

                        // reset car position and rotation
                        car.position = new BABYLON.Vector3.Zero()
                        car.rotationQuaternion = carStartRotation.clone();
                        carWheels[0].rotation.y = 0
                        carWheels[1].rotation.y = Math.PI

                        // reset camera
                        camera.alpha = cameraStartAlpha;
                        camera.beta = cameraStartBeta;
                        camera.radius = cameraStartRadius
                        camera.attachControl(canvas, true)
                        camera.parent = car

                        fail = false
                    }

                    function lose() { // called when player failed to achieve the objective
                        // show lose screen
                        image.isVisible = true
                        text1.isVisible = true
                        button.isVisible = true
                        
                        camera.detachControl(canvas)
                        camera.parent = null
                        stopCarPhysicsTimeout = setTimeout(stopCarPhysics, 1000)
                        fail = true
                    }

                    function update() { // function for codes that needs constant loop

                        // console.log(camera2.rotation)

                        // input, add thrust to car physics
                        if (mf == true) {
                            translate(car, new BABYLON.Vector3(-1, 0, 0), 1);
                            if (carWheels[0].rotation.y < -0.05)
                                rotate(car, new BABYLON.Vector3(0, -1, 0), -carWheels[0].rotation.y/4);
                            if (carWheels[0].rotation.y > 0.05)
                                rotate(car, new BABYLON.Vector3(0, 1, 0), carWheels[0].rotation.y/4);
                        }
                        if (mb == true) {
                            translate(car, new BABYLON.Vector3(1, 0, 0), 1);
                            if (carWheels[0].rotation.y < -0.05)
                                rotate(car, new BABYLON.Vector3(0, 1, 0), -carWheels[0].rotation.y/4);
                            if (carWheels[0].rotation.y > 0.05)
                                rotate(car, new BABYLON.Vector3(0, -1, 0), carWheels[0].rotation.y/4);
                        }
                        if (rl == true) {
                            if (carWheels[0].rotation.y < -0.5) {
                            }
                            else {
                                carWheels[0].rotation.y += -0.05
                                carWheels[1].rotation.y += -0.05
                                carSterringWheel.rotation.x += -0.05
                            }
                        }
                        if (rr == true) {
                            if (carWheels[0].rotation.y > 0.5) {
                            }
                            else {
                                carWheels[0].rotation.y += 0.05
                                carWheels[1].rotation.y += 0.05
                                carSterringWheel.rotation.x += 0.05
                            }
                        }
                        if (brake == true) {
                            if (car.physicsImpostor.getLinearVelocity().x < 0) 
                                translate(car, new BABYLON.Vector3(-1, 0, 0), -1);
                            if (car.physicsImpostor.getLinearVelocity().x > 0) 
                                translate(car, new BABYLON.Vector3(1, 0, 0), -1);
                        }

                        // car wheel rotation physics
                        if (car.physicsImpostor.getLinearVelocity().x < -0.1 || car.physicsImpostor.getLinearVelocity().x > 0.1) {
                            carWheels.forEach((mesh, index) => {
                                if (index%2)
                                mesh.rotation.z += car.physicsImpostor.getLinearVelocity().x/16
                                else 
                                mesh.rotation.z -= car.physicsImpostor.getLinearVelocity().x/16
                            })
                        }

                        // cutscene
                        if (cutscene_mode > 0) {
                            cutscene1Logic()
                        }
                    }

                    scene.registerBeforeRender(function () {
                        update();
                    })

                    return scene;
                }

                var scene = createScene();

                // Wait for textures and shaders to be ready
                scene.executeWhenReady(function () {
                    engine.hideLoadingUI();

                    // Once the scene is loaded, just register a render loop to render it
                    engine.runRenderLoop(function () {
                        scene.render();
                    });

                    // Resize canvas if window is resized
                    window.addEventListener("resize", () => {
                        engine.resize()
                    })
                });
            });

        </script>
    </body>
</html>