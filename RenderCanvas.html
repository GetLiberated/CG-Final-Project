<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Car Driving</title>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <style>
            html,body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #canvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id ="canvas"></canvas>
        <script>
            window.addEventListener("DOMContentLoaded", function(){
                var canvas = document.getElementById("canvas");
                var engine = new BABYLON.Engine(canvas, true);

                var createScene = function() {
                    var scene = new BABYLON.Scene(engine);

                    // enable debug mode
                    // scene.debugLayer.show()

                    // enable physics
                    scene.enablePhysics(new BABYLON.Vector3(0,-32, 0), new BABYLON.OimoJSPlugin());

                    // camera
                    var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 20, new BABYLON.Vector3(0, 0, 0), scene);
                    camera.setPosition(new BABYLON.Vector3(25, 10, 0));	  
                    camera.attachControl(canvas, true)
                    camera.inputs.attached.pointers.buttons = [0] // disable right mouse button drag
                    let cameraStartAlpha = camera.alpha
                    let cameraStartBeta = camera.beta
                    let cameraStartRadius = camera.radius
                    camera.checkCollisions = true;
                    
                    // lights
                    var light1 = new BABYLON.DirectionalLight("light1", new BABYLON.Vector3(1, 2, 0), scene);
                    var light2 = new BABYLON.HemisphericLight("light2", new BABYLON.Vector3(0, 1, 0), scene);
                    light2.intensity = 0.75;

                    // glow layer
                    var gl = new BABYLON.GlowLayer("glow", scene, { 
                        mainTextureFixedSize: 1024,
                        blurKernelSize: 64
                    });
                    
                    /***************************Car*********************************************/
                    
                    var createCar = () => {
                        //Car Body Material 
                        var bodyMaterial = new BABYLON.StandardMaterial("body_mat", scene);
                        bodyMaterial.diffuseColor = new BABYLON.Color3(1.0, 0.25, 0.25);
                        bodyMaterial.backFaceCulling = false;
                        bodyMaterial.alpha = 0

                        //Array of points for trapezium side of car.
                        var side = [new BABYLON.Vector3(-6.5, 1.5, -2),
                                    new BABYLON.Vector3(2.5, 1.5, -2),
                                    new BABYLON.Vector3(3.5, 0.5, -2),
                                    new BABYLON.Vector3(-9.5, 0.5, -2)				
                        ];
                        
                        side.push(side[0]);	//close trapezium
                        
                        //Array of points for the extrusion path
                        var extrudePath = [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 4)];
                        
                        //Create body and apply material
                        var carBody = BABYLON.MeshBuilder.ExtrudeShape("body", {shape: side, path: extrudePath, cap : BABYLON.Mesh.CAP_ALL}, scene);
                        carBody.material = bodyMaterial;
                        carBody.physicsImpostor = new BABYLON.PhysicsImpostor(carBody, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 1, friction: 0.4, restitution: 0.8}, scene);

                        return carBody
                    }
                    
                    var car = createCar()
                    camera.parent = car;
                    let carStartRotation = car.rotationQuaternion.clone();

                    let carWheels = []
                    let carLights = [[], []]
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Volkswagen Touareg 2/model/", "Touareg.obj", scene, (meshes) => {
                        meshes.forEach((mesh, index) => {
                            mesh.parent = car
                            mesh.position = new BABYLON.Vector3(-2, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(0.0035, 0.0035, 0.0035);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)

                            // let mat = new BABYLON.StandardMaterial('mat', scene);
                            // mat.diffuseTexture = new BABYLON.Texture("T-Rex/Medie"+index+".jpg");
                            // mesh.material = mat;

                            let wheelIndex = [562,570,573,542,553,594,579,584,592,603,608,610,596,600,598,606,604,602,564,568,566,572,576,574,586,590,580,578,582,588,550,558,548,560,554,546,556,544,552]
                            wheelIndex.forEach(i => {
                                if (i == index) {
                                    mesh.dispose()
                                }
                            })

                            let leftLightIndex = [474, 506, 231]
                            leftLightIndex.forEach(i => {
                                if (i == index) {
                                    carLightStartMaterial = mesh.material
                                    carLights[0].push(mesh)
                                }
                            })

                            let rightLightIndex = [462, 496, 215]
                            rightLightIndex.forEach(i => {
                                if (i == index) {
                                    carLights[1].push(mesh)
                                }
                            })

                            // mesh identifier

                            // mesh.showBoundingBox = true;
                            // mesh.actionManager = new BABYLON.ActionManager(scene);
                            // mesh.actionManager.registerAction(
                            //     new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                            //         function(event) {
                            //             console.log(index);
                            //             mesh.dispose()
                            //         }
                            //     )
                            // )
                            
                        });

                        new BABYLON.SceneLoader.ImportMesh(null, "./assets/Volkswagen Touareg 2/model/", "Tire.obj", scene, (meshes) => {
                            let carWheel = BABYLON.Mesh.MergeMeshes(meshes, true, true, undefined, false, true)
                            carWheel.parent = car
                            carWheel.position = new BABYLON.Vector3(-7, 1.2, 2.8)
                            carWheel.scaling = new BABYLON.Vector3(0.0035, 0.0035, 0.0035);
                            carWheel.rotation = new BABYLON.Vector3(0, 0, 0)
                            carWheels.push(carWheel)
                            
                            let carWheel2 = carWheel.createInstance()
                            carWheel2.parent = car
                            carWheel2.position = new BABYLON.Vector3(-7, 1.2, -2.94)
                            carWheel2.rotation = new BABYLON.Vector3(0, Math.PI, 0)
                            carWheels.push(carWheel2)

                            let carWheel3 = carWheel.createInstance()
                            carWheel3.parent = car
                            carWheel3.position = new BABYLON.Vector3(3, 1.2, 2.8)
                            carWheels.push(carWheel3)

                            let carWheel4 = carWheel.createInstance()
                            carWheel4.parent = car
                            carWheel4.position = new BABYLON.Vector3(3, 1.2, -2.94)
                            carWheel4.rotation = new BABYLON.Vector3(0, Math.PI, 0)
                            carWheels.push(carWheel4)
                        })
                    });
                    
                    /***************************End Car*********************************************/
                    
                    /*****************************Map********************************************/

                    let mapMeshes;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Objects Real.obj", scene, (meshes) => {
                        mapMeshes = meshes
                        meshes.forEach((mesh, index) => {
                            mesh.position = new BABYLON.Vector3(0, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                            // mesh.showBoundingBox = true;
                            mesh.checkCollisions = true
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);

                            // check for collisions
                            car.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function(main, collided) {
                                if (!fail) {
                                    // console.log(collided.object.name)
                                    lose()
                                }
                            });
                        });
                    });

                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Road.obj", scene, (meshes) => {
                        meshes.forEach((mesh, index) => {
                            mesh.position = new BABYLON.Vector3(0, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                            // mesh.showBoundingBox = true;
                            mesh.checkCollisions = true
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0 , friction: 0.8}, scene);
                        });
                    });

                    // var box1 = BABYLON.Mesh.CreateBox("box1", 5, scene);
                    // box1.scaling = new BABYLON.Vector3(3, 3, 3);
                    // box1.rotation.x = Math.PI/3;
                    // box1.rotation.y = -190;
                    // box1.position.x -= 100;
                    // box1.position.y -= 3;
                    // box1.physicsImpostor = new BABYLON.PhysicsImpostor(box1,BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.01, restitution: 0 }, scene);

                    /*****************************End Map********************************************/ 
                    
                    /*****************************Skybox********************************************/ 

                    let skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:500}, scene)
                    let skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene)
                    skyboxMaterial.backFaceCulling = false
                    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("./assets/skybox/skybox", scene)
                    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE

                    skybox.infiniteDistance = true
                    skyboxMaterial.disableLighting = true
                    skybox.material = skyboxMaterial

                    scene.fogMode = BABYLON.Scene.FOGMODE_EXP
                    scene.fogDensity = 0.002
                    scene.fogColor = new BABYLON.Color3(0.7, 0.7, 1)

                    /*****************************End Skybox********************************************/

                    /*********Animations*************/

                    var frameRate = 20

                    //for camera to sweep round
                    var rotate = new BABYLON.Animation("rotate", "rotation.y", frameRate, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    
                    var rotate_keys = []; 

                    rotate_keys.push({
                        frame: 0,
                        value: 0
                    });

                    rotate_keys.push({
                        frame: 9 * frameRate,
                        value: 0
                    });

                    rotate_keys.push({
                        frame: 14 * frameRate,
                        value: Math. PI
                    });

                    rotate.setKeys(rotate_keys);
                    
                    //for camera move forward
                    var movein = new BABYLON.Animation("movein", "position", frameRate, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
                    
                    var movein_keys = []; 

                    movein_keys.push({
                        frame: 0,
                        value: new BABYLON.Vector3(0, 5, -30)
                    });

                    movein_keys.push({
                        frame: 3 * frameRate,
                        value: new BABYLON.Vector3(0, 2, -10)
                    });

                    movein_keys.push({
                        frame: 5 * frameRate,
                        value: new BABYLON.Vector3(0, 2, -10)
                    });

                    movein_keys.push({
                        frame: 8 * frameRate,
                        value: new BABYLON.Vector3(-2, 2, 3)
                    });

                    movein.setKeys(movein_keys);

                    /*******Run Clips**********/

                    // scene.beginDirectAnimation(camera, [movein, rotate], 0, 25 * frameRate, false);

                    /*********End Animations*************/

                    /*****************************GUI********************************************/ 

                    var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

                    var image = new BABYLON.GUI.Image("", "./assets/black.png");
                    image.alpha = 0.5
                    image.isVisible = false
                    gui.addControl(image);    

                    var text1 = new BABYLON.GUI.TextBlock();
                    text1.text = "You died";
                    text1.color = "white";
                    text1.fontSize = 80;
                    text1.top = "-100px"
                    text1.isVisible = false
                    gui.addControl(text1); 

                    var button = BABYLON.GUI.Button.CreateSimpleButton("", "Retry");
                    button.width = 0.2;
                    button.height = "40px";
                    button.color = "white";
                    button.background = "red";
                    button.isVisible = false
                    button.onPointerClickObservable.add(function () {
                        image.isVisible = false
                        text1.isVisible = false
                        button.isVisible = false
                        window.clearTimeout(stopCarPhysicsTimeout)
                        restart()
                    });
                    gui.addControl(button); 

                    /*****************************End GUI********************************************/
                    
                    /*****************************Physics********************************************/

                    function transformForce(mesh, vec) {
                        var mymatrix = new BABYLON.Matrix();
                        mesh.rotationQuaternion.toRotationMatrix(mymatrix);
                        return BABYLON.Vector3.TransformNormal(vec, mymatrix);
                    };

                    var rotate = function(mesh, direction, power) {
                        // console.log("angular y: " + mesh.physicsImpostor.getAngularVelocity().y);
                        var maxRotation = 1;

                        // limit left rotation
                        if (mesh.physicsImpostor.getAngularVelocity().y < -maxRotation) 
                            mesh.physicsImpostor.setAngularVelocity( 
                                new BABYLON.Vector3(mesh.physicsImpostor.getAngularVelocity().x, -maxRotation, mesh.physicsImpostor.getAngularVelocity().z)
                            );

                        // limit right rotation
                        if (mesh.physicsImpostor.getAngularVelocity().y > maxRotation) 
                            mesh.physicsImpostor.setAngularVelocity( 
                                new BABYLON.Vector3(mesh.physicsImpostor.getAngularVelocity().x, maxRotation, mesh.physicsImpostor.getAngularVelocity().z)
                            );
                                
                        mesh.physicsImpostor.setAngularVelocity(
                            mesh.physicsImpostor.getAngularVelocity().add(
                                direction.scale(power)
                            )
                        );
                    }

                    var translate = function(mesh, direction, power) {
                        // console.log("linear x: " + mesh.physicsImpostor.getLinearVelocity().x);
                        var maxSpeed = 50;

                        // limit forward velocity speed
                        if (mesh.physicsImpostor.getLinearVelocity().x < -maxSpeed) 
                            mesh.physicsImpostor.setLinearVelocity(
                                new BABYLON.Vector3( -maxSpeed, mesh.physicsImpostor.getLinearVelocity().y, mesh.physicsImpostor.getLinearVelocity().z)
                            );

                        // limit backward velocity speed
                        if (mesh.physicsImpostor.getLinearVelocity().x > maxSpeed) 
                            mesh.physicsImpostor.setLinearVelocity(
                                new BABYLON.Vector3( maxSpeed, mesh.physicsImpostor.getLinearVelocity().y, mesh.physicsImpostor.getLinearVelocity().z)
                            );

                        mesh.physicsImpostor.setLinearVelocity(
                            mesh.physicsImpostor.getLinearVelocity().add(
                                transformForce(mesh, direction.scale(power))
                            )
                        );
                    }

                    /*****************************End Physics********************************************/

                    /*****************************Input********************************************/

                    var mf = false; // move forward
                    var mb = false; // move backward
                    var rl = false; // rotate left
                    var rr = false; // rotate right
                    var brake = false

                    var left_indicator_turned_on = false;
                    var left_indicator;
                    var right_indicator_turned_on = false;
                    var right_indicator;
                    var carLightStartMaterial;
                    
                    window.addEventListener('keydown',function (e) {
                        if (!fail) {
                            switch (e.keyCode) {
                                case 87://w
                                    mf = true;
                                    break;
                                case 83://s
                                    mb = true;
                                    break;
                                case 65://a
                                    rl = true;
                                    break;
                                case 68://d
                                    rr = true;
                                    break;
                                case 32://space
                                    brake = true
                                    break;
                                case 82://r
                                    restart()
                                    break;
                                case 81://q
                                    right_indicator_turned_on = false
                                    clearInterval(right_indicator)
                                    if (!left_indicator_turned_on)
                                        left_indicator = setInterval( function() { blink(0); }, 500 );
                                    else {
                                        clearInterval(left_indicator)
                                        carLights.forEach((array, index) => {
                                            array.forEach((mesh, index) => {
                                                mesh.material = carLightStartMaterial
                                            })
                                        })
                                    }
                                    left_indicator_turned_on = !left_indicator_turned_on
                                    break;
                                case 69://e
                                    left_indicator_turned_on = false
                                    clearInterval(left_indicator)
                                    if (!right_indicator_turned_on)
                                        right_indicator = setInterval( function() { blink(1); }, 500 );
                                    else {
                                        clearInterval(right_indicator)
                                        carLights.forEach((array, index) => {
                                            array.forEach((mesh, index) => {
                                                mesh.material = carLightStartMaterial
                                            })
                                        })
                                    }
                                    right_indicator_turned_on = !right_indicator_turned_on
                                    break;
                            }
                        }
                    });

                    window.addEventListener('keyup',function (e) {
                        if (!fail) {
                            switch (e.keyCode) {
                                case 87://w
                                    mf = false;
                                    break;
                                case 83://s
                                    mb = false;
                                    break;
                                case 65://a
                                    rl = false;
                                    break;
                                case 68://d
                                    rr = false;
                                    break;
                                case 32://space
                                    brake = false
                                    break;
                                case 82://r
                                    break;
                                case 81://q
                                    break;
                                case 69://e
                                    break;
                            }
                        }
                    });

                    /*****************************End Input********************************************/

                    var fail = false
                    var stopCarPhysicsTimeout;

                    function stopCarPhysics() {
                        mf = false;
                        mb = false;
                        rl = false;
                        rr = false;
                    }

                    function restart() {
                        stopCarPhysics()

                        // reset car position and rotation
                        car.position = new BABYLON.Vector3.Zero()
                        car.rotationQuaternion = carStartRotation.clone();
                        carWheels[0].rotation.y = 0
                        carWheels[1].rotation.y = Math.PI

                        // reset camera
                        camera.alpha = cameraStartAlpha;
                        camera.beta = cameraStartBeta;
                        camera.radius = cameraStartRadius
                        camera.attachControl(canvas, true)
                        camera.parent = car

                        fail = false
                    }

                    function lose() { // called when player failed to achieve the objective
                        // show lose screen
                        image.isVisible = true
                        text1.isVisible = true
                        button.isVisible = true
                        
                        camera.detachControl(canvas)
                        camera.parent = null
                        stopCarPhysicsTimeout = setTimeout(stopCarPhysics, 1000)
                        fail = true
                    }

                    var state = 0

                    function blink(num) { // called for blinking car light
                        // reset material to prevent light getting stuck when stopping
                        carLights.forEach((array, index) => {
                            array.forEach((mesh, index) => {
                                mesh.material = carLightStartMaterial
                            })
                        })
                        if (state == 0) {
                            carLights[num].forEach((mesh, index) => {
                                mesh.material = new BABYLON.StandardMaterial('', scene)
                                mesh.material.diffuseColor = BABYLON.Color3.Yellow()
                                mesh.material.emissiveColor = BABYLON.Color3.Yellow()
                            })
                            state++
                        }
                        else {
                            carLights[num].forEach((mesh, index) => {
                                mesh.material = carLightStartMaterial
                            })
                            state = 0
                        }
                    }

                    var rotation = 0.05

                    function update() { // function for codes that needs constant loop
                        // add thrust to car physics
                        if (mf == true) {
                            translate(car, new BABYLON.Vector3(-1, 0, 0), 1);
                            if (carWheels[0].rotation.y < -0.05)
                                rotate(car, new BABYLON.Vector3(0, -1, 0), -carWheels[0].rotation.y/4);
                            if (carWheels[0].rotation.y > 0.05)
                                rotate(car, new BABYLON.Vector3(0, 1, 0), carWheels[0].rotation.y/4);
                        }
                        if (mb == true) {
                            translate(car, new BABYLON.Vector3(1, 0, 0), 1);
                            if (carWheels[0].rotation.y < -0.05)
                                rotate(car, new BABYLON.Vector3(0, 1, 0), -carWheels[0].rotation.y/4);
                            if (carWheels[0].rotation.y > 0.05)
                                rotate(car, new BABYLON.Vector3(0, -1, 0), carWheels[0].rotation.y/4);
                        }
                        if (rl == true) {
                            if (carWheels[0].rotation.y < -0.5) {
                            }
                            else {
                                carWheels[0].rotation.y += -rotation
                                carWheels[1].rotation.y += -rotation
                            }
                        }
                        if (rr == true) {
                            if (carWheels[0].rotation.y > 0.5) {
                            }
                            else {
                                carWheels[0].rotation.y += rotation
                                carWheels[1].rotation.y += rotation
                            }
                        }
                        if (brake == true) {
                            if (car.physicsImpostor.getLinearVelocity().x < 0) 
                                translate(car, new BABYLON.Vector3(-1, 0, 0), -1);
                            if (car.physicsImpostor.getLinearVelocity().x > 0) 
                                translate(car, new BABYLON.Vector3(1, 0, 0), -1);
                        }

                        // limit camera zoom
                        if (camera.radius > 40)
                            camera.radius = 40;
                        if (camera.radius < 20)
                            camera.radius = 20;

                        // car wheel rotation physics
                        if (car.physicsImpostor.getLinearVelocity().x < -0.1 || car.physicsImpostor.getLinearVelocity().x > 0.1) {
                            carWheels.forEach((mesh, index) => {
                                if (index%2)
                                    mesh.rotation.z += car.physicsImpostor.getLinearVelocity().x/16
                                else 
                                    mesh.rotation.z -= car.physicsImpostor.getLinearVelocity().x/16
                            })
                        }
                    }

                    scene.registerBeforeRender(function () {
                        update();
                    })

                    return scene;
                }

                var scene = createScene();

                // Wait for textures and shaders to be ready
                scene.executeWhenReady(function () {

                    // Once the scene is loaded, just register a render loop to render it
                    engine.runRenderLoop(function () {
                        scene.render();
                    });

                    // Resize canvas if window is resized
                    window.addEventListener("resize", () => {
                        engine.resize()
                    })
                });
            });

        </script>
    </body>
</html>