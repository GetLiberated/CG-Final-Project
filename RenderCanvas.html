<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

    <title>Car Simulator</title>

    <!-- Babylon.js -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://cdn.babylonjs.com/Oimo.js"></script>
    <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

    <!-- Local js -->
    <script src="./javascript/physics.js"></script>
    <script src="./javascript/car.js"></script>
    <script src="./javascript/map.js"></script>
    <script src="./javascript/npc.js"></script>
    <script src="./javascript/animation.js"></script>
    <script src="./javascript/shader.js"></script>

    <style>
        html, body {
            overflow: hidden;
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
    </style>
</head>

<body>
    <canvas id="renderCanvas"></canvas>
    <script>
        var canvas = document.getElementById("renderCanvas");
        var engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true,  disableWebGL2Support: false});

        var createScene = function () {
                            var scene = new BABYLON.Scene(engine);

                            // enable physics
                            scene.enablePhysics(new BABYLON.Vector3(0, -32, 0), new BABYLON.OimoJSPlugin());

                            // camera
                            var camera = new BABYLON.ArcRotateCamera("camera1", 0, 0, 20, new BABYLON.Vector3(0, 0, 0), scene);
                            camera.setPosition(new BABYLON.Vector3(25, 10, 0));
                            camera.attachControl(canvas, true)
                            camera.inputs.attached.pointers.buttons = [0] // disable right mouse button drag
                            camera.lowerRadiusLimit = 20 // limit zoom in scroll
                            camera.upperRadiusLimit = 40 // limit zoom out scroll
                            var cameraStartAlpha = camera.alpha
                            var cameraStartBeta = camera.beta
                            var cameraStartRadius = camera.radius
                            camera.checkCollisions = true;

                            // fps camera
                            var camera2 = new BABYLON.UniversalCamera("camera2", new BABYLON.Vector3(0, 0, 0), scene);
                            camera2.position = new BABYLON.Vector3(0.2, 4.5, 1);
                            camera2.rotation = new BABYLON.Vector3(0, 4.68, 0);

                            // lights
                            var light1 = new BABYLON.DirectionalLight("light1", new BABYLON.Vector3(1, 2, 0), scene);
                            // light1.position = new BABYLON.Vector3(20, 40, 20);
	                        // light1.intensity = 0.5;
                            var light2 = new BABYLON.HemisphericLight("light2", new BABYLON.Vector3(0, 1, 0), scene);
                            light2.intensity = 0.75;

                            // var lightSphere = BABYLON.Mesh.CreateSphere("sphere", 10, 2, scene);
                            // lightSphere.position = light1.position;
                            // lightSphere.material = new BABYLON.StandardMaterial("light", scene);
                            // lightSphere.material.emissiveColor = new BABYLON.Color3(1, 1, 0);

                            // glow layer
                            var gl = new BABYLON.GlowLayer("glow", scene, {
                                mainTextureFixedSize: 1024,
                                blurKernelSize: 64
                            });

                            // Shadows
                            // var shadowGenerator = new BABYLON.ShadowGenerator(1024, light1);
                            // shadowGenerator.useExponentialShadowMap = true;

                            // car
                            var car = createCar(scene)
                            camera.parent = car;
                            camera2.parent = car
                            var carStartRotation = car.rotationQuaternion.clone();
                            importCarModel(scene, car)

                            // map 1
                            loadMap(scene)
                            createNPC(1, new BABYLON.Vector3(-70, 0, 14), new BABYLON.Vector3(0, Math.PI/2, 0))
                            createNPC(2, new BABYLON.Vector3(-10, 0, -10), new BABYLON.Vector3(0, -Math.PI/2, 0))
                            createNPC(3, new BABYLON.Vector3(-130, 0, 30), new BABYLON.Vector3(0, 0, 0))

                            // map 2 (disabled)
                            loadMap2(scene)

                            /*****************************GUI********************************************/

                            var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

                            // goal
                            var rect1 = new BABYLON.GUI.Rectangle();
                            rect1.width = "80px";
                            rect1.height = "40px";
                            rect1.cornerRadius = 20;
                            rect1.color = "orange";
                            rect1.thickness = 4;
                            rect1.background = "orange";
                            gui.addControl(rect1);
                            rect1.linkOffsetY = -150;

                            var label = new BABYLON.GUI.TextBlock();
                            label.text = "Goal";
                            label.color = "white"
                            rect1.addControl(label);

                            var target = new BABYLON.GUI.Ellipse();
                            target.width = "30px";
                            target.height = "30px";
                            target.color = "orange";
                            target.thickness = 4;
                            target.background = "orange";
                            gui.addControl(target);

                            var line = new BABYLON.GUI.Line();
                            line.lineWidth = 4;
                            line.color = "orange";
                            line.y2 = 10;
                            line.linkOffsetY = -10;
                            gui.addControl(line);
                            line.connectedControl = rect1;

                            // objective
                            var rect = new BABYLON.GUI.Rectangle();
                            rect.width = "440px";
                            rect.height = "150px";
                            rect.cornerRadius = 20;
                            rect.background = "black";
                            rect.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                            rect.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                            rect.paddingTop = "10px"
                            rect.paddingLeft = "10px"
                            rect.alpha = 0.6
                            gui.addControl(rect);

                            var objective_text = new BABYLON.GUI.TextBlock();
                            objective_text.text = "Objective";
                            objective_text.color = "white";
                            objective_text.fontSize = 36;
                            objective_text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                            objective_text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                            objective_text.paddingTop = "16px"
                            objective_text.paddingLeft = "20px"
                            gui.addControl(objective_text);

                            var task_text = new BABYLON.GUI.TextBlock();
                            task_text.text = "Turn on right blinker before crossroad";
                            task_text.color = "white";
                            task_text.fontSize = 24;
                            task_text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                            task_text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                            task_text.top = 80
                            task_text.left = 20
                            gui.addControl(task_text);

                            var task2_text = new BABYLON.GUI.TextBlock();
                            task2_text.text = "Reach goal";
                            task2_text.color = "white";
                            task2_text.fontSize = 24;
                            task2_text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                            task2_text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                            task2_text.top = 110
                            task2_text.left = 20
                            gui.addControl(task2_text);

                            // overlay
                            var dark_overlay = new BABYLON.GUI.Image("", "./assets/black.png");
                            dark_overlay.alpha = 0.5
                            dark_overlay.isVisible = false
                            gui.addControl(dark_overlay);

                            // win screen
                            var check = new BABYLON.GUI.Image("", "./assets/check.png");
                            check.isVisible = false
                            check.stretch = BABYLON.GUI.Image.STRETCH_UNIFORM
                            check.width = 0.2
                            check.height = 0.2
                            gui.addControl(check);

                            // lose screen
                            var text1 = new BABYLON.GUI.TextBlock();
                            text1.text = "You failed";
                            text1.color = "white";
                            text1.fontSize = 80;
                            text1.top = "-100px"
                            text1.isVisible = false
                            gui.addControl(text1);

                            var button = BABYLON.GUI.Button.CreateSimpleButton("", "Retry");
                            button.width = 0.2;
                            button.height = "40px";
                            button.color = "white";
                            button.background = "red";
                            button.isVisible = false
                            button.onPointerClickObservable.add(function () {
                                dark_overlay.isVisible = false
                                text1.isVisible = false
                                button.isVisible = false
                                window.clearTimeout(stopCarPhysicsTimeout)
                                restart()
                            });
                            gui.addControl(button);

                            /*****************************End GUI********************************************/

                            /*****************************Animations********************************************/

                            var cutscene = 0
                            var camera3 = new BABYLON.UniversalCamera("camera3", new BABYLON.Vector3(0, 0, 0), scene);
                            var frameRate = 20
                            var flip = false

                            // Win Cutscene

                            function winCutscene() {
                                dark_overlay.alpha = 0
                                dark_overlay.isVisible = true
                                check.alpha = 0
                                check.isVisible = true

                                var [fadeout, blink] = winAnimation(frameRate)

                                new BABYLON.Sound("checkSFX", "./assets/SFX/Osu! Check.mp3", scene, null, {
                                    loop: false,
                                    autoplay: true
                                });
                                
                                scene.beginDirectAnimation(dark_overlay, [fadeout], 0, 25 * frameRate, false);
                                scene.beginDirectAnimation(check, [blink], 0, 25 * frameRate, false);
                            }

                            // Cutscene 1

                            function cutscene1() {
                                cutscene = 1
                                activeCamera = 3
                                scene.activeCamera = camera3

                                dark_overlay.alpha = 0
                                dark_overlay.isVisible = true
                                
                                car.physicsImpostor.dispose()
                                
                                var [camera_rotate, camera_position, car_move, fadeout] = cutscene1Animation(frameRate)

                                scene.beginDirectAnimation(camera3, [camera_position, camera_rotate], 0, 25 * frameRate, false);
                                scene.beginDirectAnimation(car, [car_move], 0, 25 * frameRate, false);
                                scene.beginDirectAnimation(dark_overlay, [fadeout], 0, 25 * frameRate, false);
                            }

                            function cutscene1Logic() {
                                if (camera3.position.x > -108) {
                                    mf = true
                                }
                                if (camera3.position.x === -108 && !flip) {
                                    mf = false
                                    car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.4, restitution: 0.8 }, scene);
                                    car.physicsImpostor.dispose()
                                    setTimeout(function () {
                                        blinkRight()
                                    }, 300)
                                    flip = true
                                }
                                if (camera3.position.x === -120 && flip) {
                                    setTimeout(function () {
                                        blinkRight()
                                        car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.4, restitution: 0.8 }, scene);
                                        rr = true
                                        setTimeout(function () {
                                            rr = false
                                        }, 100)
                                        setTimeout(function () {
                                            mf = true
                                            setTimeout(function () {
                                                gameMode() 
                                            }, 3000)
                                        }, 1000)
                                    }, 800)
                                    flip = false
                                }
                                // npc
                                persons[0].forEach(mesh => {
                                    mesh.position.x += 0.025
                                })
                                persons[1].forEach(mesh => {
                                    mesh.position.x -= 0.025
                                })
                                persons[2].forEach(mesh => {
                                    mesh.position.z += 0.025
                                })
                            }

                            cutscene1()

                            // Cutscene 2

                            function cutscene2() {
                                cutscene = 2
                                activeCamera = 3
                                scene.activeCamera = camera3
                                
                                dark_overlay.alpha = 0
                                dark_overlay.isVisible = true
                                check.isVisible = false

                                resetCar()
                                car.physicsImpostor.dispose()
                                recycle(persons)
                                persons.length = 0
                                personsAnimation.length = 0
                                createNPC(1, new BABYLON.Vector3(-155, 0, 50), new BABYLON.Vector3(0, 0, 0))
                                createNPC(2, new BABYLON.Vector3(-130, 0, 100), new BABYLON.Vector3(0, -Math.PI, 0))
                                createNPC(3, new BABYLON.Vector3(-130, 0, 110), new BABYLON.Vector3(0, -Math.PI, 0))

                                trafficLight[2].material = new BABYLON.StandardMaterial('', scene)
                                trafficLight[2].material.diffuseColor = BABYLON.Color3.Red()
                                trafficLight[2].material.emissiveColor = BABYLON.Color3.Red()

                                var [camera_rotate, camera_position, car_move, fadeout] = cutscene2Animation(frameRate)

                                scene.beginDirectAnimation(camera3, [camera_position, camera_rotate], 0, 25 * frameRate, false);
                                scene.beginDirectAnimation(car, [car_move], 0, 25 * frameRate, false);
                                scene.beginDirectAnimation(dark_overlay, [fadeout], 0, 25 * frameRate, false);
                            }

                            function cutscene2Logic() {
                                if (car.position.z === 70 && !flip) {
                                    mf = false
                                    car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.4, restitution: 0.8 }, scene);
                                    car.physicsImpostor.dispose()
                                    flip = true
                                }
                                if (car.position.z !== 70)
                                mf = true
                                if (camera3.position.z === 47.6) {
                                    if (camera3.position.x < -124.2) {
                                        trafficLight[2].material = new BABYLON.StandardMaterial('', scene)
                                        trafficLight[2].material.diffuseColor = BABYLON.Color3.Red()
                                        trafficLight[1].material = new BABYLON.StandardMaterial('', scene)
                                        trafficLight[1].material.diffuseColor = BABYLON.Color3.Yellow()
                                        trafficLight[1].material.emissiveColor = BABYLON.Color3.Yellow()
                                    }
                                    if (camera3.position.x < -125.2) {
                                        trafficLight[1].material = new BABYLON.StandardMaterial('', scene)
                                        trafficLight[1].material.diffuseColor = BABYLON.Color3.Yellow()
                                        trafficLight[0].material = new BABYLON.StandardMaterial('', scene)
                                        trafficLight[0].material.diffuseColor = BABYLON.Color3.Green()
                                        trafficLight[0].material.emissiveColor = BABYLON.Color3.Green()
                                    }
                                }
                                if (car.position.z === -20 && flip) {
                                    car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.4, restitution: 0.8 }, scene);
                                    persons[1].forEach(mesh => {
                                        mesh.position.z = 100
                                    })
                                    persons[2].forEach(mesh => {
                                        mesh.position.z = 110
                                    })
                                    gameMode()
                                    flip = false
                                }
                                
                                if (persons[2] !== undefined) {
                                    // npc
                                    persons[0].forEach(mesh => {
                                        mesh.position.z += 0.025
                                    })
                                    persons[1].forEach(mesh => {
                                        mesh.position.z -= 0.025
                                    })
                                    persons[2].forEach(mesh => {
                                        mesh.position.z -= 0.025
                                    })
                                }
                            }

                            // Cutscene 3

                            function cutscene3() {
                                cutscene = 3
                                activeCamera = 3
                                scene.activeCamera = camera3
                                // scene.activeCamera.attachControl(canvas, true);
                                
                                dark_overlay.alpha = 0
                                dark_overlay.isVisible = true
                                check.isVisible = false

                                resetCar()
                                car.physicsImpostor.dispose()

                                var [camera_rotate, camera_position, fadeout] = cutscene3Animation(frameRate)

                                scene.beginDirectAnimation(camera3, [camera_position, camera_rotate], 0, 25 * frameRate, false);
                                scene.beginDirectAnimation(dark_overlay, [fadeout], 0, 25 * frameRate, false);
                            }

                            function cutscene3Logic() {
                                if (camera3.position.x === -100 && !flip) {
                                    car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 0.4, restitution: 0.8 }, scene);
                                    gameMode()
                                    flip = true
                                }
                            }

                            /********************************************End Animations********************************************/

                            /********************************************Gameplay********************************************/

                            var fail = false
                            var success = false
                            var level = 1
                            var stopCarPhysicsTimeout;

                            function stopCarPhysics() {
                                mf = false;
                                mb = false;
                                rl = false;
                                rr = false;
                                car.physicsImpostor.setLinearVelocity(
                                    new BABYLON.Vector3.Zero()
                                );
                                car.physicsImpostor.setAngularVelocity(
                                    new BABYLON.Vector3.Zero()
                                );
                            }

                            function resetCar() {

                                // reset car physics
                                stopCarPhysics()

                                switch (level) {
                                    case 1:
                                        car.position = new BABYLON.Vector3(0, 1, 0)
                                        car.rotationQuaternion = carStartRotation.clone();
                                        break
                                    case 2:
                                        car.position = new BABYLON.Vector3(-140, 1, 120)
                                        car.rotationQuaternion = carStartRotation.clone();
                                        car.rotate(BABYLON.Axis.Y, -(Math.PI/2), BABYLON.Space.LOCAL)
                                        break
                                    case 3:
                                        car.position = new BABYLON.Vector3(-44, -12.4, -18)
                                        car.rotationQuaternion = carStartRotation.clone();
                                        car.rotate(BABYLON.Axis.Y, -(Math.PI), BABYLON.Space.LOCAL)
                                        break
                                }
                                carWheels[0].rotation.y = 0
                                carWheels[1].rotation.y = Math.PI
                                carSteeringWheel.rotation.x = -0.15
                                if (right_indicator_turned_on)
                                    blinkRight()
                                if (left_indicator_turned_on)
                                    blinkLeft()
                            }

                            function restart() {

                                // reset car to default state
                                resetCar()

                                // reset camera
                                camera.alpha = cameraStartAlpha;
                                camera.beta = cameraStartBeta;
                                camera.radius = cameraStartRadius
                                camera.attachControl(canvas, true)
                                camera.parent = car

                                personsAnimation.forEach(anim => {
                                    anim[1].stop() 
                                    anim[2].play(true) 
                                })

                                switch (level) {
                                    case 1:
                                        task_text.color = "white"
                                        break
                                    case 2:
                                        greenLight = false
                                        task_text.color = "white"
                                        trafficLight[2].material = new BABYLON.StandardMaterial('', scene)
                                        trafficLight[2].material.diffuseColor = BABYLON.Color3.Red()
                                        trafficLight[2].material.emissiveColor = BABYLON.Color3.Red()
                                        trafficLight[1].material = new BABYLON.StandardMaterial('', scene)
                                        trafficLight[1].material.diffuseColor = BABYLON.Color3.Yellow()
                                        trafficLight[0].material = new BABYLON.StandardMaterial('', scene)
                                        trafficLight[0].material.diffuseColor = BABYLON.Color3.Green()
                                        window.clearTimeout(trafficLightTimeout)
                                        trafficLightTimeout = setTimeout(function () {
                                            trafficLight[2].material = new BABYLON.StandardMaterial('', scene)
                                            trafficLight[2].material.diffuseColor = BABYLON.Color3.Red()
                                            trafficLight[1].material = new BABYLON.StandardMaterial('', scene)
                                            trafficLight[1].material.diffuseColor = BABYLON.Color3.Yellow()
                                            trafficLight[1].material.emissiveColor = BABYLON.Color3.Yellow()
                                            trafficLightTimeout = setTimeout(function () {
                                                trafficLight[1].material = new BABYLON.StandardMaterial('', scene)
                                                trafficLight[1].material.diffuseColor = BABYLON.Color3.Yellow()
                                                trafficLight[0].material = new BABYLON.StandardMaterial('', scene)
                                                trafficLight[0].material.diffuseColor = BABYLON.Color3.Green()
                                                trafficLight[0].material.emissiveColor = BABYLON.Color3.Green()
                                                greenLight = true
                                                task_text.color = "green"
                                            }, 1000)
                                        }, 6000)
                                        break
                                }

                                fail = false
                            }

                            // called when player completed all the objectives
                            function win() { 
                                success = true
                                winCutscene()
                                setTimeout(function () {
                                    success = false
                                    goal.dispose()
                                    switch (level) {
                                        case 1:
                                            level = 2
                                            goal = createGoal(new BABYLON.Vector3(-140, 2, -46))
                                            task_text.text = "Wait for the green light";
                                            task_text.color = "white";
                                            task2_text.color = "white";
                                            cutscene2()
                                            break
                                        case 2:
                                            level = 3
                                            goal = createGoal(new BABYLON.Vector3(-20, -10, -6))
                                            task_text.text = "Park the car facing forward";
                                            task_text.color = "white";
                                            task2_text.isVisible = false
                                            rect1.height = "30px";
                                            recycle([mapMeshes, trafficLightMeshes, roadMeshes])
                                            recycle(persons)
                                            mapMeshes2.forEach(mesh => {
                                                mesh.setEnabled(true)
                                            })
                                            roadMeshes2.forEach(mesh => {
                                                mesh.setEnabled(true)
                                            })
                                            cutscene3()
                                            break
                                    }
                                }, 1500)
                            }

                            // called when player failed to complete the objectives
                            function lose() { 
                                // show lose screen
                                dark_overlay.isVisible = true
                                text1.isVisible = true
                                button.isVisible = true

                                camera.detachControl(canvas)
                                camera.parent = null
                                stopCarPhysicsTimeout = setTimeout(stopCarPhysics, 1000)
                                fail = true
                            }

                            function gameMode() {
                                cutscene = 0
                                activeCamera = 2
                                changeCamera()
                                dark_overlay.alpha = 0.5
                                dark_overlay.isVisible = false
                                if (level !== 3) {
                                    mapMeshes.forEach((mesh, index) => {
                                        car.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function (main, collided) {
                                            if (!fail && !success) {
                                                switch (Math.floor(Math.random() * 2) + 1) {
                                                    case 1:
                                                        new BABYLON.Sound("bump1", "./assets/SFX/Bump1.mp3", scene, null, {
                                                            loop: false,
                                                            autoplay: true
                                                        });
                                                        break
                                                    case 2:
                                                        new BABYLON.Sound("bump1", "./assets/SFX/Bump2.mp3", scene, null, {
                                                            loop: false,
                                                            autoplay: true
                                                        });
                                                        break
                                                }
                                                lose()
                                            }
                                        });
                                    });
                                    persons.forEach((person, index) => {
                                        person.forEach(mesh => {
                                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 1, friction: 0, restitution: 0}, scene);
                                            car.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function (main, collided) {
                                                if (!fail && !success) {
                                                    personsAnimation[index][2].stop()
                                                    personsAnimation[index][0].play()
                                                    personsAnimation.forEach((anim, i) => {
                                                        if (i !== index) {
                                                            personsAnimation[i][2].stop()
                                                            anim[1].play(true)
                                                        } 
                                                    })
                                                    lose()
                                                }
                                            });
                                        })
                                    })
                                }
                                else {
                                    mapMeshes2.forEach((mesh, index) => {
                                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);
                                        car.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function (main, collided) {
                                            if (!fail && !success) {
                                                switch (Math.floor(Math.random() * 2) + 1) {
                                                    case 1:
                                                        new BABYLON.Sound("bump1", "./assets/SFX/Bump1.mp3", scene, null, {
                                                            loop: false,
                                                            autoplay: true
                                                        });
                                                        break
                                                    case 2:
                                                        new BABYLON.Sound("bump1", "./assets/SFX/Bump2.mp3", scene, null, {
                                                            loop: false,
                                                            autoplay: true
                                                        });
                                                        break
                                                }
                                                lose()
                                            }
                                        });
                                    });
                                    roadMeshes2.forEach((mesh, index) => {
                                        mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0 , friction: 0.8}, scene);
                                    });
                                }
                                restart()
                            }

                            function createGoal(position) {
                                // create goal
                                var goal = BABYLON.MeshBuilder.CreateCylinder("goal", { height: 20, diameter: 8 });
                                goal.position = position;

                                // create material for goal
                                var mat = new BABYLON.StandardMaterial()
                                goal.material = mat
                                goal.material.diffuseColor = BABYLON.Color3.Yellow()
                                // goal.material.emissiveColor = BABYLON.Color3.Yellow()
                                goal.material.alpha = 0.7

                                // attach goal gui to goal
                                rect1.linkWithMesh(goal);
                                line.linkWithMesh(goal);
                                target.linkWithMesh(goal);

                                return goal
                            }

                            /*****************************Level 1**********************************************/

                            // create goal
                            var goal = createGoal(new BABYLON.Vector3(-144, 2, 46))

                            function level1(right_indicator_turned_on) {
                                if (car.position.z > 35) {
                                    if (!fail && !success) {
                                        task2_text.color = "green"
                                        win()
                                    }
                                }
                                if (car.position.z < -30) {
                                    task_text.color = "white"
                                    lose()
                                }
                                if (car.position.x < -90 && task_text.color !== "green") {
                                    lose()
                                }
                                else if (right_indicator_turned_on) {
                                    task_text.color = "green"
                                    if (fail) {
                                        task_text.color = "white"
                                    }
                                }
                                // npc
                                if (personsAnimation.every(anim => anim[2].isPlaying === true)) {
                                    persons[0].forEach(mesh => {
                                        mesh.position.x += 0.15
                                    })
                                    persons[1].forEach(mesh => {
                                        mesh.position.x -= 0.15
                                    })
                                    persons[2].forEach(mesh => {
                                        mesh.position.z += 0.15
                                    })
                                }
                            }

                            /*****************************End Level 1**********************************************/

                            /*****************************Level 2**********************************************/

                            var trafficLightTimeout;
                            var greenLight = false

                            function level2() {
                                if (car.position.z < -33) {
                                    if (!fail && !success) {
                                        task2_text.color = "green"
                                        win()
                                    }
                                }
                                if (car.position.z < 60 && !greenLight) {
                                    lose()
                                }
                                // npc
                                if (personsAnimation.every(anim => anim[2].isPlaying === true)) {
                                    persons[0].forEach(mesh => {
                                        mesh.position.z += 0.15
                                    })
                                    persons[1].forEach(mesh => {
                                        mesh.position.z -= 0.15
                                    })
                                    persons[2].forEach(mesh => {
                                        mesh.position.z -= 0.15
                                    })
                                }
                            }

                            /*****************************End Level 2**********************************************/

                            /********************************************End Gameplay********************************************/

                            /*****************************Input********************************************/

                            var mf = false; // move forward
                            var mb = false; // move backward
                            var rl = false; // rotate left
                            var rr = false; // rotate right
                            var brake = false

                            var activeCamera = 1

                            function changeCamera() {
                                if (activeCamera === 1) {
                                    activeCamera = 2;
                                    camera.detachControl(canvas);
                                }
                                else if (activeCamera === 2) {
                                    activeCamera = 1;
                                    camera2.detachControl(canvas);
                                }
                                scene.activeCamera = activeCamera === 1 ? camera : camera2;
                                activeCamera === 1 && camera.attachControl(canvas, false)
                            }

                            window.addEventListener('keydown', function (e) {
                                if (cutscene < 1 && !fail && !success) {
                                    switch (e.keyCode) {
                                        case 87://w
                                            mf = true;
                                            break;
                                        case 83://s
                                            mb = true;
                                            break;
                                        case 65://a
                                            rl = true;
                                            break;
                                        case 68://d
                                            rr = true;
                                            break;
                                        case 32://space
                                            brake = true
                                            var mat = new BABYLON.StandardMaterial('', scene)
                                            mat.diffuseColor = BABYLON.Color3.Red()
                                            mat.emissiveColor = BABYLON.Color3.Red()
                                            carLights[1][0].material = carLights[0][0].material = mat
                                            break;
                                        case 82://r
                                            restart()
                                            break;
                                        case 81://q
                                            blinkLeft()
                                            break;
                                        case 69://e
                                            blinkRight()
                                            break;
                                        case 86://v
                                            changeCamera()
                                            break;
                                        case 49://1
                                            gameMode()
                                            break;
                                    }
                                }
                            });

                            window.addEventListener('keyup', function (e) {
                                if (cutscene < 1 && !fail && !success) {
                                    switch (e.keyCode) {
                                        case 87://w
                                            mf = false;
                                            break;
                                        case 83://s
                                            mb = false;
                                            break;
                                        case 65://a
                                            rl = false;
                                            break;
                                        case 68://d
                                            rr = false;
                                            break;
                                        case 32://space
                                            brake = false
                                            carLights[1][0].material = carLights[0][0].material = carLightStartMaterial
                                            break;
                                        case 82://r
                                            break;
                                        case 81://q
                                            break;
                                        case 69://e
                                            break;
                                        case 86://v
                                            break;
                                    }
                                }
                            });

                            /*****************************End Input********************************************/

                            var vroomSFX = new BABYLON.Sound("vroomSFX", "./assets/SFX/Driving.mp3", scene, null, {
                                loop: true
                            });

                            function recycle(arr) {
                                arr.forEach((meshes, index) => {
                                    meshes.forEach(mesh => {
                                        mesh.dispose()
                                    })
                                })
                            }

                            function update() { // function for codes that needs constant loop

                                // console.log(car.position)
                                // console.log(car.rotationQuaternion.y)
                                // console.log("pos " + camera3.position)
                                // console.log("rot " + camera3.rotation)

                                // input
                                // add thrust to car physics
                                if (mf == true) {
                                        translate(car, new BABYLON.Vector3(-1, 0, 0), 1);
                                    if (carWheels[0].rotation.y < -0.05)
                                        rotate(car, new BABYLON.Vector3(0, -1, 0), -carWheels[0].rotation.y / 4);
                                    if (carWheels[0].rotation.y > 0.05)
                                        rotate(car, new BABYLON.Vector3(0, 1, 0), carWheels[0].rotation.y / 4);
                                    if (!vroomSFX.isPlaying && !fail && !success) {
                                        vroomSFX.play();
                                    }
                                }
                                if (!mf) {
                                    if (vroomSFX.isPlaying) {
                                        vroomSFX.stop();
                                        vroomSFX.isPlaying = false; // make sure that vroomSFX.stop is called only once
                                    }
                                }
                                if (mb == true) {
                                        translate(car, new BABYLON.Vector3(1, 0, 0), 1);
                                    if (carWheels[0].rotation.y < -0.05)
                                        rotate(car, new BABYLON.Vector3(0, 1, 0), -carWheels[0].rotation.y / 4);
                                    if (carWheels[0].rotation.y > 0.05)
                                        rotate(car, new BABYLON.Vector3(0, -1, 0), carWheels[0].rotation.y / 4);
                                }
                                if (rl == true) {
                                    if (carWheels[0].rotation.y < -0.5) {
                                    }
                                    else {
                                        carWheels[0].rotation.y += -0.05
                                        carWheels[1].rotation.y += -0.05
                                        carSteeringWheel.rotation.x += -0.05
                                    }
                                }
                                if (rr == true) {
                                    if (carWheels[0].rotation.y > 0.5) {
                                    }
                                    else {
                                        carWheels[0].rotation.y += 0.05
                                        carWheels[1].rotation.y += 0.05
                                        carSteeringWheel.rotation.x += 0.05
                                    }
                                }
                                if (brake == true) {
                                    if (car.physicsImpostor.getLinearVelocity().x < -0.5)
                                        translate(car, new BABYLON.Vector3(-1, 0, 0), -1);
                                    else if (car.physicsImpostor.getLinearVelocity().x > 0.5)
                                        translate(car, new BABYLON.Vector3(1, 0, 0), -1);
                                    else {
                                        car.physicsImpostor.setLinearVelocity(
                                            new BABYLON.Vector3.Zero()
                                        );
                                    }
                                }

                                // car wheel rotation physics
                                if (car.physicsImpostor.getLinearVelocity().x < -0.1 || car.physicsImpostor.getLinearVelocity().x > 0.1) {
                                    carWheels.forEach((mesh, index) => {
                                        if (index % 2)
                                            mesh.rotation.z += car.physicsImpostor.getLinearVelocity().x / 16
                                        else
                                            mesh.rotation.z -= car.physicsImpostor.getLinearVelocity().x / 16
                                    })
                                }
                                if (car.physicsImpostor.getLinearVelocity().z < -0.1 || car.physicsImpostor.getLinearVelocity().z > 0.1) {
                                    carWheels.forEach((mesh, index) => {
                                        if (index % 2)
                                            mesh.rotation.z += car.physicsImpostor.getLinearVelocity().z / 16
                                        else
                                            mesh.rotation.z -= car.physicsImpostor.getLinearVelocity().z / 16
                                    })
                                }

                                // cutscene
                                if (cutscene === 0) {
                                    if (level === 1) {
                                        level1(right_indicator_turned_on)
                                    }
                                    if (level === 2) {
                                        level2()
                                    }
                                }
                                if (cutscene === 1)
                                cutscene1Logic()
                                if (cutscene === 2)
                                cutscene2Logic()
                                if (cutscene === 3)
                                cutscene3Logic()
                            }

                            // show inspector
                            // scene.debugLayer.show({embedMode: true});
                            
                            // display loading screen while loading assets
                            engine.displayLoadingUI();

                            // Load the sound and play it automatically once ready
                            var music = new BABYLON.Sound("Music", "./assets/Music/#8 regret (Dedf1sh) - Splatoon 2_ Octo Expansion Music Extended (64 kbps).mp3", scene, null, {
                                loop: true,
                                autoplay: true
                            });

                            // set the global sound volume
                            BABYLON.Engine.audioEngine.setGlobalVolume(0.5);

                            // disable backface culling for new material loaded
                            scene.onNewMaterialAddedObservable.add(function(mat) {
                                mat.backFaceCulling = false;
                            });

                            scene.registerBeforeRender(function () {
                                update();
                            })

                            return scene;
        }

        var scene = createScene();

        // Wait for textures and shaders to be ready
        scene.executeWhenReady(function () {
            engine.hideLoadingUI();

            // Once the scene is loaded, just register a render loop to render it
            engine.runRenderLoop(function () {
                scene.render();
            });

            // Resize canvas if window is resized
            window.addEventListener("resize", () => {
                engine.resize()
            })
        });

        // var nodeMaterial = new BABYLON.NodeMaterial("nodeMat", scene, {
            //     emitComments: true
            // });
            // nodeMaterial.loadAsync("https://gist.githubusercontent.com/dannybucksch/8c1e194a526b8420039481dceb77995d/raw/e75f2d3bbda4ea2528d2995c613bec50595cdf4e/mouse_sine.json").then(() => {
            //     nodeMaterial.build(true);
            //     nodeMaterial.needDepthPrePass = true;
            //     nodeMaterial.backFaceCulling = false;

            //     goal.material = nodeMaterial;
            // })
    </script>
</body>

</html>