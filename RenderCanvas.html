<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Car Driving</title>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>
        <script src="./javascript/physics.js"></script>
        <script src="./javascript/car.js"></script>
        <script src="./javascript/animation.js"></script>
        <style>
            html,body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #canvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id ="canvas"></canvas>
        <script>
            window.addEventListener("DOMContentLoaded", function(){
                var canvas = document.getElementById("canvas");
                var engine = new BABYLON.Engine(canvas, true);

                // flex that engine
                engine.displayLoadingUI();

                var createScene = function() {
                    var scene = new BABYLON.Scene(engine);

                    // enable debug mode
                    // scene.debugLayer.show()

                    // enable physics
                    scene.enablePhysics(new BABYLON.Vector3(0,-32, 0), new BABYLON.OimoJSPlugin());
                       
                    // camera
                    var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 20, new BABYLON.Vector3(0, 0, 0), scene);
                    camera.setPosition(new BABYLON.Vector3(25, 10, 0));	  
                    camera.attachControl(canvas, true)
                    camera.inputs.attached.pointers.buttons = [0] // disable right mouse button drag
                    camera.lowerRadiusLimit = 20
                    camera.upperRadiusLimit = 40
                    var cameraStartAlpha = camera.alpha
                    var cameraStartBeta = camera.beta
                    var cameraStartRadius = camera.radius
                    camera.checkCollisions = true;

                    // fps camera
                    var camera2 = new BABYLON.UniversalCamera("camera2", new BABYLON.Vector3(0, 0, 0), scene);
                    camera2.position = new BABYLON.Vector3(0.2, 4.5, 1);
                    camera2.rotation = new BABYLON.Vector3(0, 4.68, 0);
                    
                    // lights
                    var light1 = new BABYLON.DirectionalLight("light1", new BABYLON.Vector3(1, 2, 0), scene);
                    var light2 = new BABYLON.HemisphericLight("light2", new BABYLON.Vector3(0, 1, 0), scene);
                    light2.intensity = 0.75;

                    // glow layer
                    var gl = new BABYLON.GlowLayer("glow", scene, { 
                        mainTextureFixedSize: 1024,
                        blurKernelSize: 64
                    });
                    
                    // car
                    var car = createCar(scene)
                    camera.parent = car;
                    camera2.parent = car
                    var carStartRotation = car.rotationQuaternion.clone();
                    
                    /*****************************Export Car Model********************************************/

                    var carWheels = []
                    var carLights = [[], []]
                    var carLightStartMaterial;
                    var carSteeringWheel;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Volkswagen Touareg 2/model/", "Touareg.obj", scene, (meshes) => {
                        meshes.forEach((mesh, index) => {
                            mesh.parent = car
                            mesh.position = new BABYLON.Vector3(-2, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(0.0035, 0.0035, 0.0035);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)

                            var wheelIndex = [562,570,573,542,553,594,579,584,592,603,608,610,596,600,598,606,604,602,564,568,566,572,576,574,586,590,580,578,582,588,550,558,548,560,554,546,556,544,552]
                            wheelIndex.forEach(i => {
                                if (i == index) {
                                    mesh.dispose()
                                }
                            })

                            var leftLightIndex = [474, 506, 231]
                            leftLightIndex.forEach(i => {
                                if (i == index) {
                                    var mat = new BABYLON.StandardMaterial('mat', scene);
                                    mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/GLBK11.jpg");
                                    mat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                                    mat.backFaceCulling = false
                                    mesh.material = mat;
                                    carLightStartMaterial = mat
                                    carLights[0].push(mesh)
                                }
                            })

                            var rightLightIndex = [462, 496, 215]
                            rightLightIndex.forEach(i => {
                                if (i == index) {
                                    var mat = new BABYLON.StandardMaterial('mat', scene);
                                    mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/GLBK11.jpg");
                                    mat.diffuseColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                                    mat.backFaceCulling = false
                                    mesh.material = mat;
                                    carLights[1].push(mesh)
                                }
                            })

                            if (index == 13 || index == 32 || index == 239) {
                                var pbr = new BABYLON.PBRMaterial("pbr", scene);
                                mesh.material = pbr;

                                pbr.metallic = 0.0;
                                pbr.roughness = 0;   
                                pbr.albedoTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/AS2_carpaint_metallic.jpg");
                                pbr.backFaceCulling = false
                            }

                            if (index == 446 || index == 24) {
                                var glass = new BABYLON.PBRMaterial("glass", scene);
                                glass.alpha = 0.5;
                                glass.reflectivityColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                                glass.albedoColor = new BABYLON.Color3(0.95, 0.95, 0.95);
                                glass.backFaceCulling = false
                                mesh.material = glass;
                            }

                            var rightLightIndex = [434, 536, 538, 540]
                            rightLightIndex.forEach(i => {
                                if (i == index) {
                                    var mat = new BABYLON.StandardMaterial('mat', scene);
                                    mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/AS2_leather_06.jpg");
                                    mat.diffuseColor = new BABYLON.Color3(1, 0.8, 0);
                                    mesh.material = mat;
                                }
                            })

                            if (index == 109) {
                                var mat = new BABYLON.StandardMaterial('mat', scene);
                                mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/Metals.Ornamental Metals.Plate.Mesh.cutout.jpg");
                                mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                                mesh.material = mat;
                            }

                            if (index == 420) {
                                carSteeringWheel = mesh
                                // mesh.dispose()
                            }

                            if (index == 438) {
                                var mat = new BABYLON.StandardMaterial('mat', scene);
                                mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/SpeedWin.jpg");
                                mat.diffuseTexture.wAng = Math.PI/2; 
                                mesh.material = mat;
                            }

                            if (index == 440) {
                                var mat = new BABYLON.StandardMaterial('mat', scene);
                                mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/computer.jpg");
                                mat.diffuseTexture.wAng = -Math.PI/2; 
                                mat.diffuseTexture.vAng = Math.PI; 
                                mesh.material = mat;
                            }

                            if (index == 293 || index == 36 || index == 68 || index == 263) {
                                var mat = new BABYLON.StandardMaterial('mat', scene);
                                mat.diffuseTexture = new BABYLON.Texture("./assets/Volkswagen Touareg 2/textures/218411094_tp.jpg");
                                mat.diffuseTexture.vAng = Math.PI; 
                                mesh.material = mat;
                            }
                            

                            if (index == 350) {
                                //Ensure working with new values for glass by computing and obtaining its worldMatrix
                                mesh.computeWorldMatrix(true);
                                var glass_worldMatrix = mesh.getWorldMatrix();
                            
                                //Obtain normals for plane and assign one of them as the normal
                                var glass_vertexData = mesh.getVerticesData("normal");
                                var glassNormal = new BABYLON.Vector3(glass_vertexData[0], glass_vertexData[1], glass_vertexData[2]);	
                                //Use worldMatrix to transform normal into its current value
                                glassNormal = new BABYLON.Vector3.TransformNormal(glassNormal, glass_worldMatrix)
                            
                                //Create reflecting surface for mirror surface
                                var reflector = new BABYLON.Plane.FromPositionAndNormal(mesh.position, glassNormal.scale(-1));
                                
                                //Create the mirror material
                                var mirrorMaterial = new BABYLON.StandardMaterial("mirror", scene);
                                mirrorMaterial.reflectionTexture = new BABYLON.MirrorTexture("mirror", 1024, scene, true);
                                mirrorMaterial.reflectionTexture.mirrorPlane = reflector;
                                mirrorMaterial.reflectionTexture.renderList = meshes;
                                mirrorMaterial.reflectionTexture.level = 1;
                            
                                // mesh.material = mirrorMaterial;
                            }

                                // mesh identifier

                                // mesh.showBoundingBox = true;
                                // mesh.actionManager = new BABYLON.ActionManager(scene);
                                // mesh.actionManager.registerAction(
                                //     new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                                //         function(event) {
                                //             console.log(index);
                                //             mesh.dispose()
                                //         }
                                //     )
                                // )
                                
                        });

                            new BABYLON.SceneLoader.ImportMesh(null, "./assets/Volkswagen Touareg 2/model/", "Tire.obj", scene, (meshes) => {
                                var carWheel = BABYLON.Mesh.MergeMeshes(meshes, true, true, undefined, false, true)
                                carWheel.parent = car
                                carWheel.position = new BABYLON.Vector3(-7, 1.2, 2.8)
                                carWheel.scaling = new BABYLON.Vector3(0.0035, 0.0035, 0.0035);
                                carWheel.rotation = new BABYLON.Vector3(0, 0, 0)
                                carWheels.push(carWheel)
                                
                                var carWheel2 = carWheel.createInstance()
                                carWheel2.parent = car
                                carWheel2.position = new BABYLON.Vector3(-7, 1.2, -2.94)
                                carWheel2.rotation = new BABYLON.Vector3(0, Math.PI, 0)
                                carWheels.push(carWheel2)

                                var carWheel3 = carWheel.createInstance()
                                carWheel3.parent = car
                                carWheel3.position = new BABYLON.Vector3(3, 1.2, 2.8)
                                carWheels.push(carWheel3)

                                var carWheel4 = carWheel.createInstance()
                                carWheel4.parent = car
                                carWheel4.position = new BABYLON.Vector3(3, 1.2, -2.94)
                                carWheel4.rotation = new BABYLON.Vector3(0, Math.PI, 0)
                                carWheels.push(carWheel4)
                            })
                        });
                    
                    /*****************************End Export Car Model********************************************/

                    /*****************************Map********************************************/

                    var mapMeshes;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Objects Real.obj", scene, (meshes) => {
                        mapMeshes = meshes
                        meshes.forEach((mesh, index) => {
                            mesh.position = new BABYLON.Vector3(0, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                            // mesh.showBoundingBox = true;
                            mesh.checkCollisions = true
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);

                            // check for collisions
                            car.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function(main, collided) {
                                if (!fail) {
                                    // console.log(collided.object.name)
                                    lose()
                                }
                            });
                        });
                    });

                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Road.obj", scene, (meshes) => {
                        meshes.forEach((mesh, index) => {
                            mesh.position = new BABYLON.Vector3(0, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                            // mesh.showBoundingBox = true;
                            mesh.checkCollisions = true
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0 , friction: 0.8}, scene);
                        });
                    });

                    // new BABYLON.SceneLoader.ImportMesh(null, "./assets/traffic light/", "traffic light.obj", scene, (meshes) => {
                    //     meshes.forEach((mesh, index) => {
                    //         mesh.position = new BABYLON.Vector3(-120, 0, -12)
                    //         mesh.scaling = new BABYLON.Vector3(0.4, 0.4, 0.4);
                    //         mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                    //         // mesh.showBoundingBox = true;
                    //         mesh.checkCollisions = true
                    //         mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);
                    //     });
                    // });

                    // var box1 = BABYLON.Mesh.CreateBox("box1", 5, scene);
                    // box1.scaling = new BABYLON.Vector3(3, 3, 3);
                    // box1.rotation.x = Math.PI/3;
                    // box1.rotation.y = -190;
                    // box1.position.x -= 100;
                    // box1.position.y -= 3;
                    // box1.physicsImpostor = new BABYLON.PhysicsImpostor(box1,BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.01, restitution: 0 }, scene);

                    /*****************************End Map********************************************/ 
                    
                    /*****************************Skybox********************************************/ 

                    var skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:500}, scene)
                    var skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene)
                    skyboxMaterial.backFaceCulling = false
                    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("./assets/skybox/skybox", scene)
                    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE

                    skybox.infiniteDistance = true
                    skyboxMaterial.disableLighting = true
                    skybox.material = skyboxMaterial

                    scene.fogMode = BABYLON.Scene.FOGMODE_EXP
                    scene.fogDensity = 0.002
                    scene.fogColor = new BABYLON.Color3(0.7, 0.7, 1)

                    /*****************************End Skybox********************************************/

                    /*****************************GUI********************************************/ 

                    var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

                    // goal
                    var rect1 = new BABYLON.GUI.Rectangle();
                    rect1.width = "80px";
                    rect1.height = "40px";
                    rect1.cornerRadius = 20;
                    rect1.color = "orange";
                    rect1.thickness = 4;
                    rect1.background = "orange";
                    gui.addControl(rect1);
                    rect1.linkOffsetY = -150;

                    var label = new BABYLON.GUI.TextBlock();
                    label.text = "Goal";
                    label.color = "white"
                    rect1.addControl(label);

                    var target = new BABYLON.GUI.Ellipse();
                    target.width = "30px";
                    target.height = "30px";
                    target.color = "orange";
                    target.thickness = 4;
                    target.background = "orange";
                    gui.addControl(target);

                    var line = new BABYLON.GUI.Line();
                    line.lineWidth = 4;
                    line.color = "orange";
                    line.y2 = 10;
                    line.linkOffsetY = -10;
                    gui.addControl(line);
                    line.connectedControl = rect1;  

                    // objective
                    var rect = new BABYLON.GUI.Rectangle();
                    rect.width = "400px";
                    rect.height = "150px";
                    rect.cornerRadius = 20;
                    rect.background = "black";
                    rect.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    rect.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                    rect.paddingTop = "10px"
                    rect.paddingLeft= "10px"
                    rect.alpha = 0.6
                    gui.addControl(rect);   

                    var objective_text = new BABYLON.GUI.TextBlock();
                    objective_text.text = "Objective";
                    objective_text.color = "white";
                    objective_text.fontSize = 36;
                    objective_text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    objective_text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                    objective_text.paddingTop = "16px"
                    objective_text.paddingLeft= "20px"
                    gui.addControl(objective_text); 

                    var task_text = new BABYLON.GUI.TextBlock();
                    task_text.text = "Blink right before perempatan";
                    task_text.color = "white";
                    task_text.fontSize = 24;
                    task_text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    task_text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                    task_text.top = 80
                    task_text.left = 20
                    gui.addControl(task_text); 

                    var task2_text = new BABYLON.GUI.TextBlock();
                    task2_text.text = "Reach goal";
                    task2_text.color = "white";
                    task2_text.fontSize = 24;
                    task2_text.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
                    task2_text.textVerticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                    task2_text.top = 110
                    task2_text.left = 20
                    gui.addControl(task2_text); 

                    // overlay
                    var image = new BABYLON.GUI.Image("", "./assets/black.png");
                    image.alpha = 0.5
                    image.isVisible = false
                    gui.addControl(image);    
                    
                    // lose screen
                    var text1 = new BABYLON.GUI.TextBlock();
                    text1.text = "You failed";
                    text1.color = "white";
                    text1.fontSize = 80;
                    text1.top = "-100px"
                    text1.isVisible = false
                    gui.addControl(text1); 

                    var button = BABYLON.GUI.Button.CreateSimpleButton("", "Retry");
                    button.width = 0.2;
                    button.height = "40px";
                    button.color = "white";
                    button.background = "red";
                    button.isVisible = false
                    button.onPointerClickObservable.add(function () {
                        image.isVisible = false
                        text1.isVisible = false
                        button.isVisible = false
                        window.clearTimeout(stopCarPhysicsTimeout)
                        restart()
                    });
                    gui.addControl(button); 

                    // win screen
                    var check = new BABYLON.GUI.Image("", "./assets/check.png");
                    check.isVisible = false
                    check.stretch = BABYLON.GUI.Image.STRETCH_UNIFORM
                    check.width = 0.2
                    check.height = 0.2
                    gui.addControl(check);  

                    /*****************************End GUI********************************************/

                    /*****************************Animations********************************************/

                    var cutscene = 0
                    var camera3 = new BABYLON.UniversalCamera("camera3",  new BABYLON.Vector3(0, 0, 0), scene);
                    var frameRate = 20
                    var flip = false

                    // win animation
                    function winCutscene() {
                        image.alpha = 0
                        image.isVisible = true
                        check.alpha = 0
                        check.isVisible = true

                        var [fadeout, blink] = winAnimation(frameRate)

                        scene.beginDirectAnimation(image, [fadeout], 0, 25 * frameRate, false);
                        scene.beginDirectAnimation(check, [blink], 0, 25 * frameRate, false);
                    }
                    
                    /*************Cutscene 1*************/
                    
                    function cutscene1() {

                        cutscene = 1
                        activeCamera = 3
                        // camera3.attachControl(scene, false)
                        scene.activeCamera = camera3  
                        car.physicsImpostor.dispose()
                        image.alpha = 0
                        image.isVisible = true
    
                        var [camera_rotate, camera_position, car_move, fadeout] = cutscene1Animation(frameRate)
                        
                        scene.beginDirectAnimation(camera3, [camera_position, camera_rotate], 0, 25 * frameRate, false);
                        scene.beginDirectAnimation(car, [car_move], 0, 25 * frameRate, false);
                        scene.beginDirectAnimation(image, [fadeout], 0, 25 * frameRate, false);
                    }

                    function cutscene1Logic() {
                        if (camera3.position.x > -108) {
                            mf = true
                        }
                        if (camera3.position.x === -108 && !flip) {
                            mf = false
                            car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 1, friction: 0.4, restitution: 0.8}, scene);
                            car.physicsImpostor.dispose()
                            setTimeout(function () {
                                blinkRight()
                            }, 300)
                            flip = true
                        }
                        if (camera3.position.x === -120 && flip) {
                            setTimeout(function () {
                                blinkRight()
                                car.physicsImpostor = new BABYLON.PhysicsImpostor(car, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 1, friction: 0.4, restitution: 0.8}, scene);
                                rr = true
                                setTimeout(function () {
                                    rr = false
                                }, 100)
                                setTimeout(function () {
                                    mf = true
                                    setTimeout(function () {
                                        cutscene = 0
                                        activeCamera = 2
                                        changeCamera()
                                        image.alpha = 0.5
                                        image.isVisible = false
                                        mapMeshes.forEach((mesh, index) => {
                                            car.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function(main, collided) {
                                                if (!fail) {
                                                    lose()
                                                }
                                            });
                                        });
                                        car.physicsImpostor.registerOnPhysicsCollide(sphere.physicsImpostor, function(main, collided) {
                                            if (!fail) {
                                                task2_text.color = "green"
                                                sphere.physicsImpostor.dispose()
                                                win()
                                            }
                                        });
                                        restart()
                                    },3000) 
                                }, 1000)
                            }, 800)
                            flip = false
                        }
                    }

                    cutscene1()

                    /*************End Cutscene 1*************/

                    /*************Cutscene 2*************/


                    /********************************************End Animations********************************************/

                    /*****************************Level 1**********************************************/

                    // create goal sphere
                    var sphere = BABYLON.Mesh.CreateSphere("sphere1", 16, 2, scene);
                    sphere.position = new BABYLON.Vector3(-145, 2, 46);

                    // create pbr material for sphere
                    var pbr = new BABYLON.PBRMetallicRoughnessMaterial("pbr", scene);
                    sphere.material = pbr;
                    pbr.baseColor = new BABYLON.Color3(1.0, 0.766, 0.336);
                    pbr.metallic = 1.0;
                    pbr.roughness = 0.0;
                    pbr.environmentTexture = BABYLON.CubeTexture.CreateFromPrefilteredData("/assets/environment.dds", scene);
                    
                    // add physics to sphere for collision detection
                    sphere.physicsImpostor = new BABYLON.PhysicsImpostor(sphere, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);

                    // attach goal gui to sphere
                    rect1.linkWithMesh(sphere);   
                    line.linkWithMesh(sphere);   
                    target.linkWithMesh(sphere);   

                    function level1() {
                        if (car.position.x < -90 && !task_text.color !== "green") {
                            lose()
                        }
                        else if (right_indicator_turned_on) {
                            task_text.color = "green"
                            if (fail) {
                                task_text.color = "white"
                                blinkRight()
                            }
                        }
                    }

                    /*****************************End Level 1**********************************************/

                    /*****************************Input********************************************/

                    var mf = false; // move forward
                    var mb = false; // move backward
                    var rl = false; // rotate left
                    var rr = false; // rotate right
                    var brake = false

                    var left_indicator_turned_on = false;
                    var left_indicator;
                    var right_indicator_turned_on = false;
                    var right_indicator;

                    var activeCamera = 1
                    var blinker_state = 0 // blinker state is on or off

                    function blink(num) { // called for blinking car light
                        // reset material to prevent light getting stuck when stopping
                        carLights.forEach((array, index) => {
                            array.forEach((mesh, index) => {
                                mesh.material = carLightStartMaterial
                            })
                        })
                        if (blinker_state == 0) {
                            carLights[num].forEach((mesh, index) => {
                                mesh.material = new BABYLON.StandardMaterial('', scene)
                                mesh.material.diffuseColor = BABYLON.Color3.Yellow()
                                mesh.material.emissiveColor = BABYLON.Color3.Yellow()
                            })
                            blinker_state++
                        }
                        else {
                            carLights[num].forEach((mesh, index) => {
                                mesh.material = carLightStartMaterial
                            })
                            blinker_state = 0
                        }
                    }

                    function blinkLeft() {
                        right_indicator_turned_on = false
                        clearInterval(right_indicator)
                        if (!left_indicator_turned_on)
                            left_indicator = setInterval( function() { blink(0); }, 500 );
                        else {
                            clearInterval(left_indicator)
                            carLights.forEach((array, index) => {
                                array.forEach((mesh, index) => {
                                    mesh.material = carLightStartMaterial
                                })
                            })
                        }
                        left_indicator_turned_on = !left_indicator_turned_on
                    }

                    function blinkRight() {
                        left_indicator_turned_on = false
                        clearInterval(left_indicator)
                        if (!right_indicator_turned_on)
                            right_indicator = setInterval( function() { blink(1); }, 500 );
                        else {
                            clearInterval(right_indicator)
                            carLights.forEach((array, index) => {
                                array.forEach((mesh, index) => {
                                    mesh.material = carLightStartMaterial
                                })
                            })
                        }
                        right_indicator_turned_on = !right_indicator_turned_on
                    }

                    function changeCamera() {
                        if(activeCamera === 1) {
                            activeCamera = 2;
                            camera.detachControl(canvas);
                        }
                        else if(activeCamera === 2) {
                            activeCamera = 1;
                            camera2.detachControl(canvas);
                        }
                        scene.activeCamera = activeCamera === 1 ? camera : camera2;
                        activeCamera === 1 && camera.attachControl(canvas, false)
                    }
                    
                    window.addEventListener('keydown',function (e) {
                        if (!fail) {
                            switch (e.keyCode) {
                                case 87://w
                                    mf = true;
                                    break;
                                case 83://s
                                    mb = true;
                                    break;
                                case 65://a
                                    rl = true;
                                    break;
                                case 68://d
                                    rr = true;
                                    break;
                                case 32://space
                                    brake = true
                                    break;
                                case 82://r
                                    restart()
                                    break;
                                case 81://q
                                    blinkLeft()
                                    break;
                                case 69://e
                                    blinkRight()
                                    break;
                                case 86://v
                                    changeCamera()
                                    break;
                            }
                        }
                    });

                    window.addEventListener('keyup',function (e) {
                        if (!fail) {
                            switch (e.keyCode) {
                                case 87://w
                                    mf = false;
                                    break;
                                case 83://s
                                    mb = false;
                                    break;
                                case 65://a
                                    rl = false;
                                    break;
                                case 68://d
                                    rr = false;
                                    break;
                                case 32://space
                                    brake = false
                                    break;
                                case 82://r
                                    break;
                                case 81://q
                                    break;
                                case 69://e
                                    break;
                                case 86://v
                                    break;
                            }
                        }
                    });

                    /*****************************End Input********************************************/

                    var fail = false
                    var level = 1
                    var stopCarPhysicsTimeout;

                    function stopCarPhysics() {
                        mf = false;
                        mb = false;
                        rl = false;
                        rr = false;
                        car.physicsImpostor.setLinearVelocity(
                            new BABYLON.Vector3(0, 0, 0)
                        );
                        car.physicsImpostor.setAngularVelocity(
                            new BABYLON.Vector3(0, 0, 0)
                        );
                    }

                    function restart() {
                        stopCarPhysics()

                        // reset car position and rotation
                        car.position = new BABYLON.Vector3.Zero()
                        car.rotationQuaternion = carStartRotation.clone();
                        carWheels[0].rotation.y = 0
                        carWheels[1].rotation.y = Math.PI

                        // reset camera
                        camera.alpha = cameraStartAlpha;
                        camera.beta = cameraStartBeta;
                        camera.radius = cameraStartRadius
                        camera.attachControl(canvas, true)
                        camera.parent = car

                        fail = false
                    }

                    function win() { // called when player succesfully achieved the objective
                        winCutscene()
                        setTimeout(function () {
                            switch (level) {
                                case 1:
                                    
                                    break
                            }
                        }, 1000)
                    }

                    function lose() { // called when player failed to achieve the objective
                        // show lose screen
                        image.isVisible = true
                        text1.isVisible = true
                        button.isVisible = true
                        
                        camera.detachControl(canvas)
                        camera.parent = null
                        stopCarPhysicsTimeout = setTimeout(stopCarPhysics, 1000)
                        fail = true
                    }

                    function update() { // function for codes that needs constant loop

                        // console.log(car.position)

                        // input, add thrust to car physics
                        if (mf == true) {
                            translate(car, new BABYLON.Vector3(-1, 0, 0), 1);
                            if (carWheels[0].rotation.y < -0.05)
                                rotate(car, new BABYLON.Vector3(0, -1, 0), -carWheels[0].rotation.y/4);
                            if (carWheels[0].rotation.y > 0.05)
                                rotate(car, new BABYLON.Vector3(0, 1, 0), carWheels[0].rotation.y/4);
                        }
                        if (mb == true) {
                            translate(car, new BABYLON.Vector3(1, 0, 0), 1);
                            if (carWheels[0].rotation.y < -0.05)
                                rotate(car, new BABYLON.Vector3(0, 1, 0), -carWheels[0].rotation.y/4);
                            if (carWheels[0].rotation.y > 0.05)
                                rotate(car, new BABYLON.Vector3(0, -1, 0), carWheels[0].rotation.y/4);
                        }
                        if (rl == true) {
                            if (carWheels[0].rotation.y < -0.5) {
                            }
                            else {
                                carWheels[0].rotation.y += -0.05
                                carWheels[1].rotation.y += -0.05
                                carSteeringWheel.rotation.x += -0.05
                            }
                        }
                        if (rr == true) {
                            if (carWheels[0].rotation.y > 0.5) {
                            }
                            else {
                                carWheels[0].rotation.y += 0.05
                                carWheels[1].rotation.y += 0.05
                                carSteeringWheel.rotation.x += 0.05
                            }
                        }
                        if (brake == true) {
                            if (car.physicsImpostor.getLinearVelocity().x < 0) 
                                translate(car, new BABYLON.Vector3(-1, 0, 0), -1);
                            if (car.physicsImpostor.getLinearVelocity().x > 0) 
                                translate(car, new BABYLON.Vector3(1, 0, 0), -1);
                        }

                        // car wheel rotation physics
                        if (car.physicsImpostor.getLinearVelocity().x < -0.1 || car.physicsImpostor.getLinearVelocity().x > 0.1) {
                            carWheels.forEach((mesh, index) => {
                                if (index%2)
                                mesh.rotation.z += car.physicsImpostor.getLinearVelocity().x/16
                                else 
                                mesh.rotation.z -= car.physicsImpostor.getLinearVelocity().x/16
                            })
                        }

                        // cutscene
                        switch (cutscene) {
                            case 0:
                                // level
                                switch (level) {
                                    case 1:
                                        level1()
                                        break
                                }
                            case 1:
                                cutscene1Logic()
                                break
                        }
                    }

                    scene.registerBeforeRender(function () {
                        update();
                    })

                    return scene;
                }

                var scene = createScene();

                // Wait for textures and shaders to be ready
                scene.executeWhenReady(function () {
                    engine.hideLoadingUI();

                    // Once the scene is loaded, just register a render loop to render it
                    engine.runRenderLoop(function () {
                        scene.render();
                    });

                    // Resize canvas if window is resized
                    window.addEventListener("resize", () => {
                        engine.resize()
                    })
                });
            });

        </script>
    </body>
</html>