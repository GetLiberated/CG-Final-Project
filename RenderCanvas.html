<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Car Driving</title>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/cannon.js"></script>
        <style>
            html,body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #canvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id ="canvas"></canvas>
        <div id=“lcContainer”>
            <ul id=“listColliders”></ul>
        </div>
        <script>
            window.addEventListener("DOMContentLoaded", function(){
                var canvas = document.getElementById("canvas");
                var engine = new BABYLON.Engine(canvas,true);

                var createScene = function() {
                    var scene = new BABYLON.Scene(engine);

                    // camera
                    var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 20, new BABYLON.Vector3(0, 0, 0), scene);
                    camera.setPosition(new BABYLON.Vector3(25, 10, 0));	  
                    
                    // lights
                    var light1 = new BABYLON.DirectionalLight("light1", new BABYLON.Vector3(1, 2, 0), scene);
                    var light2 = new BABYLON.HemisphericLight("light2", new BABYLON.Vector3(0, 1, 0), scene);
                    light2.intensity = 0.75;
                    
                    /***************************Car*********************************************/
                    
                    /*-----------------------Car Body------------------------------------------*/ 
                    
                    //Car Body Material 
                    var bodyMaterial = new BABYLON.StandardMaterial("body_mat", scene);
                    bodyMaterial.diffuseColor = new BABYLON.Color3(1.0, 0.25, 0.25);
                    bodyMaterial.backFaceCulling = false;

                    //Array of points for trapezium side of car.
                    var side = [new BABYLON.Vector3(-6.5, 1.5, -2),
                                new BABYLON.Vector3(2.5, 1.5, -2),
                                new BABYLON.Vector3(3.5, 0.5, -2),
                                new BABYLON.Vector3(-9.5, 0.5, -2)				
                    ];
                    
                    side.push(side[0]);	//close trapezium
                    
                    //Array of points for the extrusion path
                    var extrudePath = [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 4)];
                    
                    //Create body and apply material
                    var carBody = BABYLON.MeshBuilder.ExtrudeShape("body", {shape: side, path: extrudePath, cap : BABYLON.Mesh.CAP_ALL}, scene);
                    carBody.material = bodyMaterial;
                    camera.parent = carBody;

                    let car;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Volkswagen Touareg 2/model/", "Touareg.obj", scene, (obj) => {
                        car = obj;
                        obj.forEach((object, index) => {
                            object.parent = carBody
                            object.position = new BABYLON.Vector3(-2, -1, 0)
                            object.scaling = new BABYLON.Vector3(0.0035, 0.0035, 0.0035);
                            object.rotation = new BABYLON.Vector3(0, 0, 0)

                            // let mat = new BABYLON.StandardMaterial('mat', scene);
                            // mat.diffuseTexture = new BABYLON.Texture("T-Rex/Medie"+index+".jpg");
                            // object.material = mat;
                        });
                    });
                    /*-----------------------End Car Body------------------------------------------*/
                    
                    /*-----------------------Wheel------------------------------------------*/ 
                    
                    //Wheel Material 
                    var wheelMaterial = new BABYLON.StandardMaterial("wheel_mat", scene);
                    var wheelTexture = new BABYLON.Texture("assets/wheelTexture.png", scene);
                    wheelMaterial.diffuseTexture = wheelTexture;
                    
                    //Set color for wheel tread as black
                    var faceColors=[];
                    faceColors[1] = new BABYLON.Color3(0,0,0);
                    
                    //set texture for flat face of wheel 
                    var faceUV =[];
                    faceUV[0] = new BABYLON.Vector4(0,0,1,1);
                    faceUV[2] = new BABYLON.Vector4(0,0,1,1);
                    
                    //create wheel front inside and apply material
                    var wheelFI = BABYLON.MeshBuilder.CreateCylinder("wheelFI", {diameter: 3, height: 1, tessellation: 24, faceColors:faceColors, faceUV:faceUV}, scene);
                    wheelFI.material = wheelMaterial;
                    
                    //rotate wheel so tread in xz plane  
                    wheelFI.rotate(BABYLON.Axis.X, Math.PI/2, BABYLON.Space.WORLD); 	
                    /*-----------------------End Wheel------------------------------------------*/ 
                    
                    /*-------------------Pivots for Front Wheels-----------------------------------*/
                    var pivotFI = new BABYLON.Mesh("pivotFI", scene);
                    pivotFI.parent = carBody;
                    pivotFI.position = new BABYLON.Vector3(-7, 0, -1.5);
                    
                    var pivotFO = new BABYLON.Mesh("pivotFO", scene);
                    pivotFO.parent = carBody;
                    pivotFO.position = new BABYLON.Vector3(-7, 0, 1.5);  
                    /*----------------End Pivots for Front Wheels--------------------------------*/
                    
                    /*------------Create other Wheels as Instances, Parent and Position----------*/
                    var wheelFO = wheelFI.createInstance("FO");
                    wheelFO.parent = pivotFO;
                    wheelFO.position = new BABYLON.Vector3(0, 0, 1.8);
                    
                    var wheelRI = wheelFI.createInstance("RI");
                    wheelRI.parent = carBody;
                    wheelRI.position = new BABYLON.Vector3(3, 0, -2.8);
                    
                    var wheelRO = wheelFI.createInstance("RO");
                    wheelRO.parent = carBody;
                    wheelRO.position = new BABYLON.Vector3(3, 0, 2.8);
                    
                    wheelFI.parent = pivotFI;
                    wheelFI.position = new BABYLON.Vector3(0, 0, -1.8);
                    /*------------End Create other Wheels as Instances, Parent and Position----------*/
                    
                    /*---------------------Create Car Centre of Rotation-----------------------------*/
                    pivot = new BABYLON.Mesh("pivot", scene); //current centre of rotation
                    pivot.position.z = 50;
                    carBody.parent = pivot;
                    carBody.position = new BABYLON.Vector3(0, 0, -50);
                    
                    /*---------------------End Create Car Centre of Rotation-------------------------*/
                    
                    
                    /*************************** End Car*********************************************/
                    
                    /*****************************Map********************************************/
                    // var groundSize = 400;
                    
                    // var ground = BABYLON.MeshBuilder.CreateGround("ground", {width: groundSize, height: groundSize}, scene);
                    // var groundMaterial = new BABYLON.StandardMaterial("ground", scene);
                    // groundMaterial.diffuseColor = new BABYLON.Color3(0.75, 1, 0.25);
                    // ground.material = groundMaterial;
                    // ground.position.y = -1.5;

                    let mapMesh;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Objects Real.obj", scene, (obj) => {
                        mapMesh = obj;
                        obj.forEach((object, index) => {
                            object.position = new BABYLON.Vector3(0, 0, 0)
                            object.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            object.rotation = new BABYLON.Vector3(0, 0, 0)

                            if(carBody.intersectsMesh(object, true)){
                                console.log(object.name)
                                // carBody.position.copyFrom(lastPosition)
                            }
                        });
                    });

                    let road;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Road.obj", scene, (obj) => {
                        road = obj;
                        obj.forEach((object, index) => {
                            object.position = new BABYLON.Vector3(0, 0, 0)
                            object.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            object.rotation = new BABYLON.Vector3(0, 0, 0)
                        });
                    });

                    /*****************************End Map********************************************/ 
                    
                    /*****************************Skybox********************************************/ 
                    let skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:500}, scene)
                    let skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene)
                    skyboxMaterial.backFaceCulling = false
                    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("./assets/skybox/skybox", scene)
                    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE

                    skybox.infiniteDistance = true
                    skyboxMaterial.disableLighting = true
                    skybox.material = skyboxMaterial

                    scene.fogMode = BABYLON.Scene.FOGMODE_EXP
                    scene.fogDensity = 0.002
                    scene.fogColor = new BABYLON.Color3(0.7, 0.7, 1)
                    /*****************************End Skybox********************************************/
                    
                    /****************************Key Controls************************************************/
                    
                    var map ={}; //object for multiple key presses
                    scene.actionManager = new BABYLON.ActionManager(scene);
                    
                    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, function (evt) {								
                            map[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                            
                        }));
                        
                    scene.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, function (evt) {								
                            map[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                        }));	
                        
                    /****************************End Key Controls************************************************/
                    
                    
                    /****************************Variables************************************************/
                    
                    var theta = 0;
                    var deltaTheta = 0;
                    var D = 0; //distance translated per second
                    var R = 50; //turning radius, initial set at pivot z value
                    var NR; //Next turning radius on wheel turn
                    var A = 4; // axel length
                    var L = 4; //distance between wheel pivots
                    var r = 1.5; // wheel radius
                    var psi, psiRI, psiRO, psFI, psiFO; //wheel rotations  
                    var phi; //rotation of car when turning 
                    
                    var F; // frames per second	

                    var G = 1; // gear
                    
                    /****************************End Variables************************************************/
                    

                    
                    /****************************Animation******************************************************/	
                    
                    scene.registerAfterRender(function() {	
                        F = engine.getFps();

                        /***************Switch Gear****************/
                        if(map["1"]) {
                            G = 1	
                        };

                        if(map["2"]) {
                            G = 2	
                        };

                        if(map["3"]) {
                            G = 3	
                        };

                        if(map["4"]) {
                            G = 4	
                        };

                        if(map["5"]) {
                            G = 5	
                        };
                        /***************End Switch Gear****************/
                        
                        if(map["w"] && D < 30 && G == 1) {
                            D += 1	
                        };

                        if(map["w"] && D < 40 && G == 2) {
                            D += 2
                        };

                        if(map["w"] && D < 50 && G == 3) {
                            D += 3
                        };

                        if(map["w"] && D < 60 && G == 4) {
                            D += 4
                        };

                        if(map["w"] && D < 80 && G == 5) {
                            D += 5
                        };

                        // Handbrake
                        if(map[" "] && D > 0) {
                            D -= 1.5
                        };
                        
                        // Acceleration when not thrusting
                        if(D > 0.15) {
                            D -= 0.1;
                        } 
                        else if (D < -0.15) {
                            D += 0.1;
                        }
                        // else {
                        //     D = 0;
                        // }
                                    
                        distance = D/F;
                        psi = D/(r * F);
                        
                        if((map["a"] || map["A"]) && -Math.PI/8 < theta) {
                            deltaTheta = -Math.PI/252;
                            theta += deltaTheta;
                            pivotFI.rotate(BABYLON.Axis.Y, deltaTheta, BABYLON.Space.LOCAL);
                            pivotFO.rotate(BABYLON.Axis.Y, deltaTheta, BABYLON.Space.LOCAL);
                            if(Math.abs(theta) > 0.00000001) {
                                NR = A/2 +L/Math.tan(theta);	
                            }
                            else {
                                theta = 0;
                                NR = 0;
                            }
                            pivot.translate(BABYLON.Axis.Z, NR - R, BABYLON.Space.LOCAL);
                            carBody.translate(BABYLON.Axis.Z, R - NR, BABYLON.Space.LOCAL);
                            R = NR;
                                                    
                        };
                            
                        if((map["d"] || map["D"])  && theta < Math.PI/8) {
                            deltaTheta = Math.PI/252;
                            theta += deltaTheta;
                            pivotFI.rotate(BABYLON.Axis.Y, deltaTheta, BABYLON.Space.LOCAL);
                            pivotFO.rotate(BABYLON.Axis.Y, deltaTheta, BABYLON.Space.LOCAL);
                            if(Math.abs(theta) > 0.00000001) {
                                NR = A/2 +L/Math.tan(theta);	
                            }
                            else {
                                theta = 0;
                                NR = 0;
                            }
                            pivot.translate(BABYLON.Axis.Z, NR - R, BABYLON.Space.LOCAL);
                            carBody.translate(BABYLON.Axis.Z, R - NR, BABYLON.Space.LOCAL);
                            R = NR;
                                    
                        };

                        if(map["s"] && D > -30 ) {
                            D -= 1
                        };
                        
                        if(D > 0) {
                            phi = D/(R * F);
                            if(Math.abs(theta)>0) {	 
                                pivot.rotate(BABYLON.Axis.Y, phi, BABYLON.Space.WORLD);
                                psiRI = D/(r * F);
                                psiRO = D * (R + A)/(r * F);
                                psiFI = D * Math.sqrt(R* R + L * L)/(r * F);
                                psiFO = D * Math.sqrt((R + A) * (R + A) + L * L)/(r * F);
                            
                                wheelFI.rotate(BABYLON.Axis.Y, psiFI, BABYLON.Space.LOCAL); 
                                wheelFO.rotate(BABYLON.Axis.Y, psiFO, BABYLON.Space.LOCAL);
                                wheelRI.rotate(BABYLON.Axis.Y, psiRI, BABYLON.Space.LOCAL);
                                wheelRO.rotate(BABYLON.Axis.Y, psiRO, BABYLON.Space.LOCAL);
                            }
                            else {
                                pivot.translate(BABYLON.Axis.X, -distance, BABYLON.Space.LOCAL);
                                wheelFI.rotate(BABYLON.Axis.Y, psi, BABYLON.Space.LOCAL); 
                                wheelFO.rotate(BABYLON.Axis.Y, psi, BABYLON.Space.LOCAL);
                                wheelRI.rotate(BABYLON.Axis.Y, psi, BABYLON.Space.LOCAL);
                                wheelRO.rotate(BABYLON.Axis.Y, psi, BABYLON.Space.LOCAL);
                            }
                        }

                        if (D < 0) {
                            phi = D/(R * F);
                            if(Math.abs(theta)<0) {	 
                                pivot.rotate(BABYLON.Axis.Y, phi, BABYLON.Space.WORLD);
                                psiRI = D/(r * F);
                                psiRO = D * (R + A)/(r * F);
                                psiFI = D * Math.sqrt(R* R + L * L)/(r * F);
                                psiFO = D * Math.sqrt((R + A) * (R + A) + L * L)/(r * F);
                            
                                wheelFI.rotate(BABYLON.Axis.Y, psiFI, BABYLON.Space.LOCAL); 
                                wheelFO.rotate(BABYLON.Axis.Y, psiFO, BABYLON.Space.LOCAL);
                                wheelRI.rotate(BABYLON.Axis.Y, psiRI, BABYLON.Space.LOCAL);
                                wheelRO.rotate(BABYLON.Axis.Y, psiRO, BABYLON.Space.LOCAL);
                            }
                            else {
                                pivot.translate(BABYLON.Axis.X, -distance, BABYLON.Space.LOCAL);
                                wheelFI.rotate(BABYLON.Axis.Y, psi, BABYLON.Space.LOCAL); 
                                wheelFO.rotate(BABYLON.Axis.Y, psi, BABYLON.Space.LOCAL);
                                wheelRI.rotate(BABYLON.Axis.Y, psi, BABYLON.Space.LOCAL);
                                wheelRO.rotate(BABYLON.Axis.Y, psi, BABYLON.Space.LOCAL);
                            }
                        }
                    });
                    
                    /****************************End Animation************************************************/

                    return scene;
                }

                var scene = createScene();

                // Wait for textures and shaders to be ready
                scene.executeWhenReady(function () {
 
                    // Enable physics
                    scene.enablePhysics();

                    // Once the scene is loaded, just register a render loop to render it
                    engine.runRenderLoop(function () {
                        scene.render();
                    });

                    // Resize canvas if window is resized
                    window.addEventListener("resize", () => {
                        engine.resize()
                    })
                });
            });

            function CreateCollidersHTMLList() {

                var listColliders = document.getElementById('listColliders');

                for (var j = 0; j < meshesColliderList.length; j++) {

                    var newLi = document.createElement('li');

                    var chkVisibility = document.createElement('input');

                    chkVisibility.type = 'checkbox';

                    chkVisibility.name = meshesColliderList[j].name;

                    chkVisibility.id = 'colvis' + j;

                    var chkPhysics = document.createElement('input');

                    chkPhysics.type = 'checkbox';

                    chkPhysics.name = meshesColliderList[j].name;

                    chkPhysics.id = 'colphysx' + j;

                    (function (j) {

                        chkVisibility.addEventListener(

                        'click',

                        function (event) {

                            onChangeVisibility(j, event);

                        },

                        false

                        );

                        chkPhysics.addEventListener(

                        'click',

                        function (event) {

                            onChangePhysics(j, event);

                        },

                        false

                        );

                    })(j)

                    newLi.textContent = meshesColliderList[j].name + ' visibility/physx ';

                    newLi.appendChild(chkVisibility);

                    newLi.appendChild(chkPhysics);

                    listColliders.appendChild(newLi);

                }

                function onChangeVisibility(id, event) {

                    if (!meshesColliderList[id].isVisible) {

                        meshesColliderList[id].isVisible = true;

                        meshesColliderList[id].material.alpha = 0.75;

                        meshesColliderList[id].material.ambientColor.r = 1;

                    }

                    else {

                        meshesColliderList[id].isVisible = false;

                    }

                }

                function onChangePhysics(id, event) {

                    if (!meshesColliderList[id].checkCollisions) {

                        meshesColliderList[id].checkCollisions = true;

                        meshesColliderList[id].setPhysicsState(BABYLON.PhysicsEngine.BoxImpostor, { mass: 0, 

                                                                friction: 0.5, restitution: 0.7 });

                    }

                    else {

                        meshesColliderList[id].checkCollisions = false;

                        meshesColliderList[id].setPhysicsState(BABYLON.PhysicsEngine.NoImpostor);

                    }

                }

            }
        </script>
    </body>
</html>