<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Car Driving</title>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://cdn.babylonjs.com/Oimo.js"></script>
        <style>
            html,body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #canvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
    </head>
    <body>
        <canvas id ="canvas"></canvas>
        <script>
            window.addEventListener("DOMContentLoaded", function(){
                var canvas = document.getElementById("canvas");
                var engine = new BABYLON.Engine(canvas,true);

                var createScene = function() {
                    var scene = new BABYLON.Scene(engine);

                    // Enable physics
                    scene.enablePhysics(null, new BABYLON.OimoJSPlugin());
                    scene.collisionsEnabled = true;

                    // camera
                    var camera = new BABYLON.ArcRotateCamera("camera1",  0, 0, 20, new BABYLON.Vector3(0, 0, 0), scene);
                    camera.setPosition(new BABYLON.Vector3(25, 10, 0));	  
                    camera.checkCollisions = true;
                    
                    // lights
                    var light1 = new BABYLON.DirectionalLight("light1", new BABYLON.Vector3(1, 2, 0), scene);
                    var light2 = new BABYLON.HemisphericLight("light2", new BABYLON.Vector3(0, 1, 0), scene);
                    light2.intensity = 0.75;
                    
                    /***************************Car*********************************************/
                    
                    //Car Body Material 
                    var bodyMaterial = new BABYLON.StandardMaterial("body_mat", scene);
                    bodyMaterial.diffuseColor = new BABYLON.Color3(1.0, 0.25, 0.25);
                    bodyMaterial.backFaceCulling = false;
                    bodyMaterial.alpha = 0

                    //Array of points for trapezium side of car.
                    var side = [new BABYLON.Vector3(-6.5, 1.5, -2),
                                new BABYLON.Vector3(2.5, 1.5, -2),
                                new BABYLON.Vector3(3.5, 0.5, -2),
                                new BABYLON.Vector3(-9.5, 0.5, -2)				
                    ];
                    
                    side.push(side[0]);	//close trapezium
                    
                    //Array of points for the extrusion path
                    var extrudePath = [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 4)];
                    
                    //Create body and apply material
                    var carBody = BABYLON.MeshBuilder.ExtrudeShape("body", {shape: side, path: extrudePath, cap : BABYLON.Mesh.CAP_ALL}, scene);
                    carBody.material = bodyMaterial;
                    carBody.physicsImpostor = new BABYLON.PhysicsImpostor(carBody, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 1}, scene);
                    camera.parent = carBody;

                    let carCollider;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Volkswagen Touareg 2/model/", "Touareg.obj", scene, (meshes) => {
                        carCollider = meshes[13];
                        meshes.forEach((mesh, index) => {
                            mesh.parent = carBody
                            mesh.position = new BABYLON.Vector3(-2, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(0.0035, 0.0035, 0.0035);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)

                            // let mat = new BABYLON.StandardMaterial('mat', scene);
                            // mat.diffuseTexture = new BABYLON.Texture("T-Rex/Medie"+index+".jpg");
                            // mesh.material = mat;

                            if (index === 13) {
                                mesh.checkCollisions = true;
                                // mesh.showBoundingBox = true;
                            }
                        });
                    });
                    
                    /*************************** End Car*********************************************/
                    
                    /*****************************Map********************************************/

                    let mapMeshes;
                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Objects Real.obj", scene, (meshes) => {
                        mapMeshes = meshes
                        meshes.forEach((mesh, index) => {
                            mesh.position = new BABYLON.Vector3(0, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                            
                            mesh.checkCollisions = true;
                            // mesh.showBoundingBox = true;
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);
                        });
                    });

                    new BABYLON.SceneLoader.ImportMesh(null, "./assets/Environments/", "Road.obj", scene, (meshes) => {
                        meshes.forEach((mesh, index) => {
                            mesh.position = new BABYLON.Vector3(0, 0, 0)
                            mesh.scaling = new BABYLON.Vector3(3.2, 3.2, 3.2);
                            mesh.rotation = new BABYLON.Vector3(0, 0, 0)
                            // mesh.showBoundingBox = true;
                            mesh.physicsImpostor = new BABYLON.PhysicsImpostor(mesh, BABYLON.PhysicsImpostor.BoxImpostor, {mass: 0}, scene);
                            mesh.checkCollisions = true;
                        });
                    });

                    var box1 = BABYLON.Mesh.CreateBox("box1", 5, scene);
                    box1.scaling = new BABYLON.Vector3(3, 3, 3);
                    box1.rotation.x = Math.PI/3;
                    box1.rotation.y = -190;
                    box1.position.x -= 100;
                    box1.position.y -= 3;
                    box1.physicsImpostor = new BABYLON.PhysicsImpostor(box1,BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 0.01, restitution: 0 }, scene);

                    /*****************************End Map********************************************/ 
                    
                    /*****************************Skybox********************************************/ 

                    let skybox = BABYLON.MeshBuilder.CreateBox("skyBox", {size:500}, scene)
                    let skyboxMaterial = new BABYLON.StandardMaterial("skyBox", scene)
                    skyboxMaterial.backFaceCulling = false
                    skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture("./assets/skybox/skybox", scene)
                    skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE

                    skybox.infiniteDistance = true
                    skyboxMaterial.disableLighting = true
                    skybox.material = skyboxMaterial

                    scene.fogMode = BABYLON.Scene.FOGMODE_EXP
                    scene.fogDensity = 0.002
                    scene.fogColor = new BABYLON.Color3(0.7, 0.7, 1)

                    /*****************************End Skybox********************************************/

                    var transformForce = function (mesh, vec) {
                        var mymatrix = new BABYLON.Matrix();
                        mesh.rotationQuaternion.toRotationMatrix(mymatrix);
                        return BABYLON.Vector3.TransformNormal(vec, mymatrix);
                    };

                    var rotate = function (mesh, direction, power) {
                        // console.log("rotate happening", direction.scale(power));
                        mesh.physicsImpostor.setAngularVelocity(
                            mesh.physicsImpostor.getAngularVelocity().add(
                                direction.scale(power)
                            )
                        );
                    }

                    var translate = function (mesh, direction, power) {
                        mesh.physicsImpostor.setLinearVelocity(
                            mesh.physicsImpostor.getLinearVelocity().add(
                                transformForce(mesh, direction.scale(power))
                            )
                        );
                    }

                    var mf = false;
                    var mb = false;
                    var rl = false;
                    var rr = false;
                    
                    var oKeyBoard = {
                        bPressRight: false,
                        bPressLeft: false,
                        bPressUp: false,
                        bPressDown: false
                    };

                    window.addEventListener('keydown',function (e) {
                        switch (e.keyCode) {
                            case 87://w
                                mf = true;
                                break;
                            case 83://s
                                mb = true;
                                break;
                            case 65://a
                                rl = true;
                                break;
                            case 68://d
                                rr = true;
                                break;
                        }
                    });

                    window.addEventListener('keyup',function (e) {
                        switch (e.keyCode) {
                            case 87://w
                                mf = false;
                                break;
                            case 83://s
                                mb = false;
                                break;
                            case 65://a
                                rl = false;
                                break;
                            case 68://d
                                rr = false;
                                break;
                        }
                    });
                    
                    function update() {
                        if (mf == true) {
                            translate(carBody, new BABYLON.Vector3(-1, 0, 0), 0.5);
                        }
                        if (mb == true) {
                            translate(carBody, new BABYLON.Vector3(1, 0, 0), 0.5);
                        }
                        if (rl == true) {
                            rotate(carBody, new BABYLON.Vector3(0, -1, 0), 0.2);
                        }
                        if (rr == true) {
                            rotate(carBody, new BABYLON.Vector3(0, 1, 0), 0.2);
                        }

                        // mapMeshes.forEach((mesh, index) => {
                        //     carBody.physicsImpostor.registerOnPhysicsCollide(mesh.physicsImpostor, function(main, collided) {
                        //         console.log(collided.object.name)
                        //     });
                        // });
                    }

                    scene.registerBeforeRender(function() {
                        update();
                    });

                    return scene;
                }

                var scene = createScene();

                // Wait for textures and shaders to be ready
                scene.executeWhenReady(function () {

                    // Once the scene is loaded, just register a render loop to render it
                    engine.runRenderLoop(function () {
                        scene.render();
                    });

                    // Resize canvas if window is resized
                    window.addEventListener("resize", () => {
                        engine.resize()
                    })
                });

                // object.actionManager = new BABYLON.ActionManager(scene);
                // object.actionManager.registerAction(
                //     new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, 
                //         function(event) {
                //             console.log(index);
                //         }
                //     )
                // )
            });
        </script>
    </body>
</html>